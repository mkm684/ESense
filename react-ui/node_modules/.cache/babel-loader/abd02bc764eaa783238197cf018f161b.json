{"ast":null,"code":"'use strict';\n\nvar helpers = require('../helpers/index');\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\n\n\nfunction generateTicks(generationOptions, dataRange) {\n  var ticks = []; // To get a \"nice\" value for the tick spacing, we will use the appropriately named\n  // \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n  // for details.\n\n  var spacing;\n\n  if (generationOptions.stepSize && generationOptions.stepSize > 0) {\n    spacing = generationOptions.stepSize;\n  } else {\n    var niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n    spacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n  }\n\n  var niceMin = Math.floor(dataRange.min / spacing) * spacing;\n  var niceMax = Math.ceil(dataRange.max / spacing) * spacing; // If min, max and stepSize is set and they make an evenly spaced scale use it.\n\n  if (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n    // If very close to our whole number, use it.\n    if (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n      niceMin = generationOptions.min;\n      niceMax = generationOptions.max;\n    }\n  }\n\n  var numSpaces = (niceMax - niceMin) / spacing; // If very close to our rounded value, use it.\n\n  if (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n    numSpaces = Math.round(numSpaces);\n  } else {\n    numSpaces = Math.ceil(numSpaces);\n  }\n\n  var precision = 1;\n\n  if (spacing < 1) {\n    precision = Math.pow(10, spacing.toString().length - 2);\n    niceMin = Math.round(niceMin * precision) / precision;\n    niceMax = Math.round(niceMax * precision) / precision;\n  }\n\n  ticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\n  for (var j = 1; j < numSpaces; ++j) {\n    ticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n  }\n\n  ticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n  return ticks;\n}\n\nmodule.exports = function (Chart) {\n  var noop = helpers.noop;\n  Chart.LinearScaleBase = Chart.Scale.extend({\n    getRightValue: function getRightValue(value) {\n      if (typeof value === 'string') {\n        return +value;\n      }\n\n      return Chart.Scale.prototype.getRightValue.call(this, value);\n    },\n    handleTickRangeOptions: function handleTickRangeOptions() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n      // do nothing since that would make the chart weird. If the user really wants a weird chart\n      // axis, they can manually override it\n\n      if (tickOpts.beginAtZero) {\n        var minSign = helpers.sign(me.min);\n        var maxSign = helpers.sign(me.max);\n\n        if (minSign < 0 && maxSign < 0) {\n          // move the top up to 0\n          me.max = 0;\n        } else if (minSign > 0 && maxSign > 0) {\n          // move the bottom down to 0\n          me.min = 0;\n        }\n      }\n\n      var setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n      var setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n      if (tickOpts.min !== undefined) {\n        me.min = tickOpts.min;\n      } else if (tickOpts.suggestedMin !== undefined) {\n        if (me.min === null) {\n          me.min = tickOpts.suggestedMin;\n        } else {\n          me.min = Math.min(me.min, tickOpts.suggestedMin);\n        }\n      }\n\n      if (tickOpts.max !== undefined) {\n        me.max = tickOpts.max;\n      } else if (tickOpts.suggestedMax !== undefined) {\n        if (me.max === null) {\n          me.max = tickOpts.suggestedMax;\n        } else {\n          me.max = Math.max(me.max, tickOpts.suggestedMax);\n        }\n      }\n\n      if (setMin !== setMax) {\n        // We set the min or the max but not both.\n        // So ensure that our range is good\n        // Inverted or 0 length range can happen when\n        // ticks.min is set, and no datasets are visible\n        if (me.min >= me.max) {\n          if (setMin) {\n            me.max = me.min + 1;\n          } else {\n            me.min = me.max - 1;\n          }\n        }\n      }\n\n      if (me.min === me.max) {\n        me.max++;\n\n        if (!tickOpts.beginAtZero) {\n          me.min--;\n        }\n      }\n    },\n    getTickLimit: noop,\n    handleDirectionalChanges: noop,\n    buildTicks: function buildTicks() {\n      var me = this;\n      var opts = me.options;\n      var tickOpts = opts.ticks; // Figure out what the max number of ticks we can support it is based on the size of\n      // the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n      // We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n      // the graph. Make sure we always have at least 2 ticks\n\n      var maxTicks = me.getTickLimit();\n      maxTicks = Math.max(2, maxTicks);\n      var numericGeneratorOptions = {\n        maxTicks: maxTicks,\n        min: tickOpts.min,\n        max: tickOpts.max,\n        stepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n      };\n      var ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n      me.handleDirectionalChanges(); // At this point, we need to update our max and min given the tick values since we have expanded the\n      // range of the scale\n\n      me.max = helpers.max(ticks);\n      me.min = helpers.min(ticks);\n\n      if (tickOpts.reverse) {\n        ticks.reverse();\n        me.start = me.max;\n        me.end = me.min;\n      } else {\n        me.start = me.min;\n        me.end = me.max;\n      }\n    },\n    convertTicksToLabels: function convertTicksToLabels() {\n      var me = this;\n      me.ticksAsNumbers = me.ticks.slice();\n      me.zeroLineIndex = me.ticks.indexOf(0);\n      Chart.Scale.prototype.convertTicksToLabels.call(me);\n    }\n  });\n};","map":{"version":3,"sources":["/home/mohamed/projects/ESense/react-ui/node_modules/chart.js/src/scales/scale.linearbase.js"],"names":["helpers","require","generateTicks","generationOptions","dataRange","ticks","spacing","stepSize","niceRange","niceNum","max","min","maxTicks","niceMin","Math","floor","niceMax","ceil","almostWhole","numSpaces","almostEquals","round","precision","pow","toString","length","push","undefined","j","module","exports","Chart","noop","LinearScaleBase","Scale","extend","getRightValue","value","prototype","call","handleTickRangeOptions","me","opts","options","tickOpts","beginAtZero","minSign","sign","maxSign","setMin","suggestedMin","setMax","suggestedMax","getTickLimit","handleDirectionalChanges","buildTicks","numericGeneratorOptions","valueOrDefault","fixedStepSize","reverse","start","end","convertTicksToLabels","ticksAsNumbers","slice","zeroLineIndex","indexOf"],"mappings":"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","sourcesContent":["'use strict';\n\nvar helpers = require('../helpers/index');\n\n/**\n * Generate a set of linear ticks\n * @param generationOptions the options used to generate the ticks\n * @param dataRange the range of the data\n * @returns {Array<Number>} array of tick values\n */\nfunction generateTicks(generationOptions, dataRange) {\n\tvar ticks = [];\n\t// To get a \"nice\" value for the tick spacing, we will use the appropriately named\n\t// \"nice number\" algorithm. See http://stackoverflow.com/questions/8506881/nice-label-algorithm-for-charts-with-minimum-ticks\n\t// for details.\n\n\tvar spacing;\n\tif (generationOptions.stepSize && generationOptions.stepSize > 0) {\n\t\tspacing = generationOptions.stepSize;\n\t} else {\n\t\tvar niceRange = helpers.niceNum(dataRange.max - dataRange.min, false);\n\t\tspacing = helpers.niceNum(niceRange / (generationOptions.maxTicks - 1), true);\n\t}\n\tvar niceMin = Math.floor(dataRange.min / spacing) * spacing;\n\tvar niceMax = Math.ceil(dataRange.max / spacing) * spacing;\n\n\t// If min, max and stepSize is set and they make an evenly spaced scale use it.\n\tif (generationOptions.min && generationOptions.max && generationOptions.stepSize) {\n\t\t// If very close to our whole number, use it.\n\t\tif (helpers.almostWhole((generationOptions.max - generationOptions.min) / generationOptions.stepSize, spacing / 1000)) {\n\t\t\tniceMin = generationOptions.min;\n\t\t\tniceMax = generationOptions.max;\n\t\t}\n\t}\n\n\tvar numSpaces = (niceMax - niceMin) / spacing;\n\t// If very close to our rounded value, use it.\n\tif (helpers.almostEquals(numSpaces, Math.round(numSpaces), spacing / 1000)) {\n\t\tnumSpaces = Math.round(numSpaces);\n\t} else {\n\t\tnumSpaces = Math.ceil(numSpaces);\n\t}\n\n\tvar precision = 1;\n\tif (spacing < 1) {\n\t\tprecision = Math.pow(10, spacing.toString().length - 2);\n\t\tniceMin = Math.round(niceMin * precision) / precision;\n\t\tniceMax = Math.round(niceMax * precision) / precision;\n\t}\n\tticks.push(generationOptions.min !== undefined ? generationOptions.min : niceMin);\n\tfor (var j = 1; j < numSpaces; ++j) {\n\t\tticks.push(Math.round((niceMin + j * spacing) * precision) / precision);\n\t}\n\tticks.push(generationOptions.max !== undefined ? generationOptions.max : niceMax);\n\n\treturn ticks;\n}\n\n\nmodule.exports = function(Chart) {\n\n\tvar noop = helpers.noop;\n\n\tChart.LinearScaleBase = Chart.Scale.extend({\n\t\tgetRightValue: function(value) {\n\t\t\tif (typeof value === 'string') {\n\t\t\t\treturn +value;\n\t\t\t}\n\t\t\treturn Chart.Scale.prototype.getRightValue.call(this, value);\n\t\t},\n\n\t\thandleTickRangeOptions: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// If we are forcing it to begin at 0, but 0 will already be rendered on the chart,\n\t\t\t// do nothing since that would make the chart weird. If the user really wants a weird chart\n\t\t\t// axis, they can manually override it\n\t\t\tif (tickOpts.beginAtZero) {\n\t\t\t\tvar minSign = helpers.sign(me.min);\n\t\t\t\tvar maxSign = helpers.sign(me.max);\n\n\t\t\t\tif (minSign < 0 && maxSign < 0) {\n\t\t\t\t\t// move the top up to 0\n\t\t\t\t\tme.max = 0;\n\t\t\t\t} else if (minSign > 0 && maxSign > 0) {\n\t\t\t\t\t// move the bottom down to 0\n\t\t\t\t\tme.min = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar setMin = tickOpts.min !== undefined || tickOpts.suggestedMin !== undefined;\n\t\t\tvar setMax = tickOpts.max !== undefined || tickOpts.suggestedMax !== undefined;\n\n\t\t\tif (tickOpts.min !== undefined) {\n\t\t\t\tme.min = tickOpts.min;\n\t\t\t} else if (tickOpts.suggestedMin !== undefined) {\n\t\t\t\tif (me.min === null) {\n\t\t\t\t\tme.min = tickOpts.suggestedMin;\n\t\t\t\t} else {\n\t\t\t\t\tme.min = Math.min(me.min, tickOpts.suggestedMin);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (tickOpts.max !== undefined) {\n\t\t\t\tme.max = tickOpts.max;\n\t\t\t} else if (tickOpts.suggestedMax !== undefined) {\n\t\t\t\tif (me.max === null) {\n\t\t\t\t\tme.max = tickOpts.suggestedMax;\n\t\t\t\t} else {\n\t\t\t\t\tme.max = Math.max(me.max, tickOpts.suggestedMax);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setMin !== setMax) {\n\t\t\t\t// We set the min or the max but not both.\n\t\t\t\t// So ensure that our range is good\n\t\t\t\t// Inverted or 0 length range can happen when\n\t\t\t\t// ticks.min is set, and no datasets are visible\n\t\t\t\tif (me.min >= me.max) {\n\t\t\t\t\tif (setMin) {\n\t\t\t\t\t\tme.max = me.min + 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.min = me.max - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.min === me.max) {\n\t\t\t\tme.max++;\n\n\t\t\t\tif (!tickOpts.beginAtZero) {\n\t\t\t\t\tme.min--;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tgetTickLimit: noop,\n\t\thandleDirectionalChanges: noop,\n\n\t\tbuildTicks: function() {\n\t\t\tvar me = this;\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\n\t\t\t// Figure out what the max number of ticks we can support it is based on the size of\n\t\t\t// the axis area. For now, we say that the minimum tick spacing in pixels must be 50\n\t\t\t// We also limit the maximum number of ticks to 11 which gives a nice 10 squares on\n\t\t\t// the graph. Make sure we always have at least 2 ticks\n\t\t\tvar maxTicks = me.getTickLimit();\n\t\t\tmaxTicks = Math.max(2, maxTicks);\n\n\t\t\tvar numericGeneratorOptions = {\n\t\t\t\tmaxTicks: maxTicks,\n\t\t\t\tmin: tickOpts.min,\n\t\t\t\tmax: tickOpts.max,\n\t\t\t\tstepSize: helpers.valueOrDefault(tickOpts.fixedStepSize, tickOpts.stepSize)\n\t\t\t};\n\t\t\tvar ticks = me.ticks = generateTicks(numericGeneratorOptions, me);\n\n\t\t\tme.handleDirectionalChanges();\n\n\t\t\t// At this point, we need to update our max and min given the tick values since we have expanded the\n\t\t\t// range of the scale\n\t\t\tme.max = helpers.max(ticks);\n\t\t\tme.min = helpers.min(ticks);\n\n\t\t\tif (tickOpts.reverse) {\n\t\t\t\tticks.reverse();\n\n\t\t\t\tme.start = me.max;\n\t\t\t\tme.end = me.min;\n\t\t\t} else {\n\t\t\t\tme.start = me.min;\n\t\t\t\tme.end = me.max;\n\t\t\t}\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\tme.ticksAsNumbers = me.ticks.slice();\n\t\t\tme.zeroLineIndex = me.ticks.indexOf(0);\n\n\t\t\tChart.Scale.prototype.convertTicksToLabels.call(me);\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}