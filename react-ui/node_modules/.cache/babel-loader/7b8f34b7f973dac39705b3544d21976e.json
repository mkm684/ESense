{"ast":null,"code":"'use strict';\n\nvar defaults = require('../core/core.defaults');\n\nvar elements = require('../elements/index');\n\nvar helpers = require('../helpers/index');\n\ndefaults._set('line', {\n  showLines: true,\n  spanGaps: false,\n  hover: {\n    mode: 'label'\n  },\n  scales: {\n    xAxes: [{\n      type: 'category',\n      id: 'x-axis-0'\n    }],\n    yAxes: [{\n      type: 'linear',\n      id: 'y-axis-0'\n    }]\n  }\n});\n\nmodule.exports = function (Chart) {\n  function lineEnabled(dataset, options) {\n    return helpers.valueOrDefault(dataset.showLine, options.showLines);\n  }\n\n  Chart.controllers.line = Chart.DatasetController.extend({\n    datasetElementType: elements.Line,\n    dataElementType: elements.Point,\n    update: function update(reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var line = meta.dataset;\n      var points = meta.data || [];\n      var options = me.chart.options;\n      var lineElementOptions = options.elements.line;\n      var scale = me.getScaleForId(meta.yAxisID);\n      var i, ilen, custom;\n      var dataset = me.getDataset();\n      var showLine = lineEnabled(dataset, options); // Update Line\n\n      if (showLine) {\n        custom = line.custom || {}; // Compatibility: If the properties are defined with only the old name, use those values\n\n        if (dataset.tension !== undefined && dataset.lineTension === undefined) {\n          dataset.lineTension = dataset.tension;\n        } // Utility\n\n\n        line._scale = scale;\n        line._datasetIndex = me.index; // Data\n\n        line._children = points; // Model\n\n        line._model = {\n          // Appearance\n          // The default behavior of lines is to break at null values, according\n          // to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n          // This option gives lines the ability to span gaps\n          spanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n          tension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n          backgroundColor: custom.backgroundColor ? custom.backgroundColor : dataset.backgroundColor || lineElementOptions.backgroundColor,\n          borderWidth: custom.borderWidth ? custom.borderWidth : dataset.borderWidth || lineElementOptions.borderWidth,\n          borderColor: custom.borderColor ? custom.borderColor : dataset.borderColor || lineElementOptions.borderColor,\n          borderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : dataset.borderCapStyle || lineElementOptions.borderCapStyle,\n          borderDash: custom.borderDash ? custom.borderDash : dataset.borderDash || lineElementOptions.borderDash,\n          borderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : dataset.borderDashOffset || lineElementOptions.borderDashOffset,\n          borderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : dataset.borderJoinStyle || lineElementOptions.borderJoinStyle,\n          fill: custom.fill ? custom.fill : dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill,\n          steppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n          cubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode)\n        };\n        line.pivot();\n      } // Update Points\n\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        me.updateElement(points[i], i, reset);\n      }\n\n      if (showLine && line._model.tension !== 0) {\n        me.updateBezierControlPoints();\n      } // Now pivot the point for animation\n\n\n      for (i = 0, ilen = points.length; i < ilen; ++i) {\n        points[i].pivot();\n      }\n    },\n    getPointBackgroundColor: function getPointBackgroundColor(point, index) {\n      var backgroundColor = this.chart.options.elements.point.backgroundColor;\n      var dataset = this.getDataset();\n      var custom = point.custom || {};\n\n      if (custom.backgroundColor) {\n        backgroundColor = custom.backgroundColor;\n      } else if (dataset.pointBackgroundColor) {\n        backgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n      } else if (dataset.backgroundColor) {\n        backgroundColor = dataset.backgroundColor;\n      }\n\n      return backgroundColor;\n    },\n    getPointBorderColor: function getPointBorderColor(point, index) {\n      var borderColor = this.chart.options.elements.point.borderColor;\n      var dataset = this.getDataset();\n      var custom = point.custom || {};\n\n      if (custom.borderColor) {\n        borderColor = custom.borderColor;\n      } else if (dataset.pointBorderColor) {\n        borderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n      } else if (dataset.borderColor) {\n        borderColor = dataset.borderColor;\n      }\n\n      return borderColor;\n    },\n    getPointBorderWidth: function getPointBorderWidth(point, index) {\n      var borderWidth = this.chart.options.elements.point.borderWidth;\n      var dataset = this.getDataset();\n      var custom = point.custom || {};\n\n      if (!isNaN(custom.borderWidth)) {\n        borderWidth = custom.borderWidth;\n      } else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {\n        borderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n      } else if (!isNaN(dataset.borderWidth)) {\n        borderWidth = dataset.borderWidth;\n      }\n\n      return borderWidth;\n    },\n    updateElement: function updateElement(point, index, reset) {\n      var me = this;\n      var meta = me.getMeta();\n      var custom = point.custom || {};\n      var dataset = me.getDataset();\n      var datasetIndex = me.index;\n      var value = dataset.data[index];\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var xScale = me.getScaleForId(meta.xAxisID);\n      var pointOptions = me.chart.options.elements.point;\n      var x, y; // Compatibility: If the properties are defined with only the old name, use those values\n\n      if (dataset.radius !== undefined && dataset.pointRadius === undefined) {\n        dataset.pointRadius = dataset.radius;\n      }\n\n      if (dataset.hitRadius !== undefined && dataset.pointHitRadius === undefined) {\n        dataset.pointHitRadius = dataset.hitRadius;\n      }\n\n      x = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n      y = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex); // Utility\n\n      point._xScale = xScale;\n      point._yScale = yScale;\n      point._datasetIndex = datasetIndex;\n      point._index = index; // Desired view properties\n\n      point._model = {\n        x: x,\n        y: y,\n        skip: custom.skip || isNaN(x) || isNaN(y),\n        // Appearance\n        radius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n        pointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n        backgroundColor: me.getPointBackgroundColor(point, index),\n        borderColor: me.getPointBorderColor(point, index),\n        borderWidth: me.getPointBorderWidth(point, index),\n        tension: meta.dataset._model ? meta.dataset._model.tension : 0,\n        steppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n        // Tooltip\n        hitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n      };\n    },\n    calculatePointY: function calculatePointY(value, index, datasetIndex) {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var yScale = me.getScaleForId(meta.yAxisID);\n      var sumPos = 0;\n      var sumNeg = 0;\n      var i, ds, dsMeta;\n\n      if (yScale.options.stacked) {\n        for (i = 0; i < datasetIndex; i++) {\n          ds = chart.data.datasets[i];\n          dsMeta = chart.getDatasetMeta(i);\n\n          if (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n            var stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\n            if (stackedRightValue < 0) {\n              sumNeg += stackedRightValue || 0;\n            } else {\n              sumPos += stackedRightValue || 0;\n            }\n          }\n        }\n\n        var rightValue = Number(yScale.getRightValue(value));\n\n        if (rightValue < 0) {\n          return yScale.getPixelForValue(sumNeg + rightValue);\n        }\n\n        return yScale.getPixelForValue(sumPos + rightValue);\n      }\n\n      return yScale.getPixelForValue(value);\n    },\n    updateBezierControlPoints: function updateBezierControlPoints() {\n      var me = this;\n      var meta = me.getMeta();\n      var area = me.chart.chartArea;\n      var points = meta.data || [];\n      var i, ilen, point, model, controlPoints; // Only consider points that are drawn in case the spanGaps option is used\n\n      if (meta.dataset._model.spanGaps) {\n        points = points.filter(function (pt) {\n          return !pt._model.skip;\n        });\n      }\n\n      function capControlPoint(pt, min, max) {\n        return Math.max(Math.min(pt, max), min);\n      }\n\n      if (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n        helpers.splineCurveMonotone(points);\n      } else {\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\n          point = points[i];\n          model = point._model;\n          controlPoints = helpers.splineCurve(helpers.previousItem(points, i)._model, model, helpers.nextItem(points, i)._model, meta.dataset._model.tension);\n          model.controlPointPreviousX = controlPoints.previous.x;\n          model.controlPointPreviousY = controlPoints.previous.y;\n          model.controlPointNextX = controlPoints.next.x;\n          model.controlPointNextY = controlPoints.next.y;\n        }\n      }\n\n      if (me.chart.options.elements.line.capBezierPoints) {\n        for (i = 0, ilen = points.length; i < ilen; ++i) {\n          model = points[i]._model;\n          model.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n          model.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n          model.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n          model.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n        }\n      }\n    },\n    draw: function draw() {\n      var me = this;\n      var chart = me.chart;\n      var meta = me.getMeta();\n      var points = meta.data || [];\n      var area = chart.chartArea;\n      var ilen = points.length;\n      var i = 0;\n      helpers.canvas.clipArea(chart.ctx, area);\n\n      if (lineEnabled(me.getDataset(), chart.options)) {\n        meta.dataset.draw();\n      }\n\n      helpers.canvas.unclipArea(chart.ctx); // Draw the points\n\n      for (; i < ilen; ++i) {\n        points[i].draw(area);\n      }\n    },\n    setHoverStyle: function setHoverStyle(point) {\n      // Point\n      var dataset = this.chart.data.datasets[point._datasetIndex];\n      var index = point._index;\n      var custom = point.custom || {};\n      var model = point._model;\n      model.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n      model.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n      model.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n      model.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n    },\n    removeHoverStyle: function removeHoverStyle(point) {\n      var me = this;\n      var dataset = me.chart.data.datasets[point._datasetIndex];\n      var index = point._index;\n      var custom = point.custom || {};\n      var model = point._model; // Compatibility: If the properties are defined with only the old name, use those values\n\n      if (dataset.radius !== undefined && dataset.pointRadius === undefined) {\n        dataset.pointRadius = dataset.radius;\n      }\n\n      model.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n      model.backgroundColor = me.getPointBackgroundColor(point, index);\n      model.borderColor = me.getPointBorderColor(point, index);\n      model.borderWidth = me.getPointBorderWidth(point, index);\n    }\n  });\n};","map":{"version":3,"sources":["/home/mohamed/projects/ESense/react-ui/node_modules/chart.js/src/controllers/controller.line.js"],"names":["defaults","require","elements","helpers","_set","showLines","spanGaps","hover","mode","scales","xAxes","type","id","yAxes","module","exports","Chart","lineEnabled","dataset","options","valueOrDefault","showLine","controllers","line","DatasetController","extend","datasetElementType","Line","dataElementType","Point","update","reset","me","meta","getMeta","points","data","chart","lineElementOptions","scale","getScaleForId","yAxisID","i","ilen","custom","getDataset","tension","undefined","lineTension","_scale","_datasetIndex","index","_children","_model","backgroundColor","borderWidth","borderColor","borderCapStyle","borderDash","borderDashOffset","borderJoinStyle","fill","steppedLine","stepped","cubicInterpolationMode","pivot","length","updateElement","updateBezierControlPoints","getPointBackgroundColor","point","pointBackgroundColor","valueAtIndexOrDefault","getPointBorderColor","pointBorderColor","getPointBorderWidth","isNaN","pointBorderWidth","isArray","datasetIndex","value","yScale","xScale","xAxisID","pointOptions","x","y","radius","pointRadius","hitRadius","pointHitRadius","getPixelForValue","NaN","getBasePixel","calculatePointY","_xScale","_yScale","_index","skip","pointStyle","sumPos","sumNeg","ds","dsMeta","stacked","datasets","getDatasetMeta","isDatasetVisible","stackedRightValue","Number","getRightValue","rightValue","area","chartArea","model","controlPoints","filter","pt","capControlPoint","min","max","Math","splineCurveMonotone","splineCurve","previousItem","nextItem","controlPointPreviousX","previous","controlPointPreviousY","controlPointNextX","next","controlPointNextY","capBezierPoints","left","right","top","bottom","draw","canvas","clipArea","ctx","unclipArea","setHoverStyle","hoverRadius","pointHoverRadius","hoverBackgroundColor","pointHoverBackgroundColor","getHoverColor","hoverBorderColor","pointHoverBorderColor","hoverBorderWidth","pointHoverBorderWidth","removeHoverStyle"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('../core/core.defaults');\nvar elements = require('../elements/index');\nvar helpers = require('../helpers/index');\n\ndefaults._set('line', {\n\tshowLines: true,\n\tspanGaps: false,\n\n\thover: {\n\t\tmode: 'label'\n\t},\n\n\tscales: {\n\t\txAxes: [{\n\t\t\ttype: 'category',\n\t\t\tid: 'x-axis-0'\n\t\t}],\n\t\tyAxes: [{\n\t\t\ttype: 'linear',\n\t\t\tid: 'y-axis-0'\n\t\t}]\n\t}\n});\n\nmodule.exports = function(Chart) {\n\n\tfunction lineEnabled(dataset, options) {\n\t\treturn helpers.valueOrDefault(dataset.showLine, options.showLines);\n\t}\n\n\tChart.controllers.line = Chart.DatasetController.extend({\n\n\t\tdatasetElementType: elements.Line,\n\n\t\tdataElementType: elements.Point,\n\n\t\tupdate: function(reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar line = meta.dataset;\n\t\t\tvar points = meta.data || [];\n\t\t\tvar options = me.chart.options;\n\t\t\tvar lineElementOptions = options.elements.line;\n\t\t\tvar scale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar i, ilen, custom;\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar showLine = lineEnabled(dataset, options);\n\n\t\t\t// Update Line\n\t\t\tif (showLine) {\n\t\t\t\tcustom = line.custom || {};\n\n\t\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\t\tif ((dataset.tension !== undefined) && (dataset.lineTension === undefined)) {\n\t\t\t\t\tdataset.lineTension = dataset.tension;\n\t\t\t\t}\n\n\t\t\t\t// Utility\n\t\t\t\tline._scale = scale;\n\t\t\t\tline._datasetIndex = me.index;\n\t\t\t\t// Data\n\t\t\t\tline._children = points;\n\t\t\t\t// Model\n\t\t\t\tline._model = {\n\t\t\t\t\t// Appearance\n\t\t\t\t\t// The default behavior of lines is to break at null values, according\n\t\t\t\t\t// to https://github.com/chartjs/Chart.js/issues/2435#issuecomment-216718158\n\t\t\t\t\t// This option gives lines the ability to span gaps\n\t\t\t\t\tspanGaps: dataset.spanGaps ? dataset.spanGaps : options.spanGaps,\n\t\t\t\t\ttension: custom.tension ? custom.tension : helpers.valueOrDefault(dataset.lineTension, lineElementOptions.tension),\n\t\t\t\t\tbackgroundColor: custom.backgroundColor ? custom.backgroundColor : (dataset.backgroundColor || lineElementOptions.backgroundColor),\n\t\t\t\t\tborderWidth: custom.borderWidth ? custom.borderWidth : (dataset.borderWidth || lineElementOptions.borderWidth),\n\t\t\t\t\tborderColor: custom.borderColor ? custom.borderColor : (dataset.borderColor || lineElementOptions.borderColor),\n\t\t\t\t\tborderCapStyle: custom.borderCapStyle ? custom.borderCapStyle : (dataset.borderCapStyle || lineElementOptions.borderCapStyle),\n\t\t\t\t\tborderDash: custom.borderDash ? custom.borderDash : (dataset.borderDash || lineElementOptions.borderDash),\n\t\t\t\t\tborderDashOffset: custom.borderDashOffset ? custom.borderDashOffset : (dataset.borderDashOffset || lineElementOptions.borderDashOffset),\n\t\t\t\t\tborderJoinStyle: custom.borderJoinStyle ? custom.borderJoinStyle : (dataset.borderJoinStyle || lineElementOptions.borderJoinStyle),\n\t\t\t\t\tfill: custom.fill ? custom.fill : (dataset.fill !== undefined ? dataset.fill : lineElementOptions.fill),\n\t\t\t\t\tsteppedLine: custom.steppedLine ? custom.steppedLine : helpers.valueOrDefault(dataset.steppedLine, lineElementOptions.stepped),\n\t\t\t\t\tcubicInterpolationMode: custom.cubicInterpolationMode ? custom.cubicInterpolationMode : helpers.valueOrDefault(dataset.cubicInterpolationMode, lineElementOptions.cubicInterpolationMode),\n\t\t\t\t};\n\n\t\t\t\tline.pivot();\n\t\t\t}\n\n\t\t\t// Update Points\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tme.updateElement(points[i], i, reset);\n\t\t\t}\n\n\t\t\tif (showLine && line._model.tension !== 0) {\n\t\t\t\tme.updateBezierControlPoints();\n\t\t\t}\n\n\t\t\t// Now pivot the point for animation\n\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\tpoints[i].pivot();\n\t\t\t}\n\t\t},\n\n\t\tgetPointBackgroundColor: function(point, index) {\n\t\t\tvar backgroundColor = this.chart.options.elements.point.backgroundColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.backgroundColor) {\n\t\t\t\tbackgroundColor = custom.backgroundColor;\n\t\t\t} else if (dataset.pointBackgroundColor) {\n\t\t\t\tbackgroundColor = helpers.valueAtIndexOrDefault(dataset.pointBackgroundColor, index, backgroundColor);\n\t\t\t} else if (dataset.backgroundColor) {\n\t\t\t\tbackgroundColor = dataset.backgroundColor;\n\t\t\t}\n\n\t\t\treturn backgroundColor;\n\t\t},\n\n\t\tgetPointBorderColor: function(point, index) {\n\t\t\tvar borderColor = this.chart.options.elements.point.borderColor;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (custom.borderColor) {\n\t\t\t\tborderColor = custom.borderColor;\n\t\t\t} else if (dataset.pointBorderColor) {\n\t\t\t\tborderColor = helpers.valueAtIndexOrDefault(dataset.pointBorderColor, index, borderColor);\n\t\t\t} else if (dataset.borderColor) {\n\t\t\t\tborderColor = dataset.borderColor;\n\t\t\t}\n\n\t\t\treturn borderColor;\n\t\t},\n\n\t\tgetPointBorderWidth: function(point, index) {\n\t\t\tvar borderWidth = this.chart.options.elements.point.borderWidth;\n\t\t\tvar dataset = this.getDataset();\n\t\t\tvar custom = point.custom || {};\n\n\t\t\tif (!isNaN(custom.borderWidth)) {\n\t\t\t\tborderWidth = custom.borderWidth;\n\t\t\t} else if (!isNaN(dataset.pointBorderWidth) || helpers.isArray(dataset.pointBorderWidth)) {\n\t\t\t\tborderWidth = helpers.valueAtIndexOrDefault(dataset.pointBorderWidth, index, borderWidth);\n\t\t\t} else if (!isNaN(dataset.borderWidth)) {\n\t\t\t\tborderWidth = dataset.borderWidth;\n\t\t\t}\n\n\t\t\treturn borderWidth;\n\t\t},\n\n\t\tupdateElement: function(point, index, reset) {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar dataset = me.getDataset();\n\t\t\tvar datasetIndex = me.index;\n\t\t\tvar value = dataset.data[index];\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar xScale = me.getScaleForId(meta.xAxisID);\n\t\t\tvar pointOptions = me.chart.options.elements.point;\n\t\t\tvar x, y;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\t\t\tif ((dataset.hitRadius !== undefined) && (dataset.pointHitRadius === undefined)) {\n\t\t\t\tdataset.pointHitRadius = dataset.hitRadius;\n\t\t\t}\n\n\t\t\tx = xScale.getPixelForValue(typeof value === 'object' ? value : NaN, index, datasetIndex);\n\t\t\ty = reset ? yScale.getBasePixel() : me.calculatePointY(value, index, datasetIndex);\n\n\t\t\t// Utility\n\t\t\tpoint._xScale = xScale;\n\t\t\tpoint._yScale = yScale;\n\t\t\tpoint._datasetIndex = datasetIndex;\n\t\t\tpoint._index = index;\n\n\t\t\t// Desired view properties\n\t\t\tpoint._model = {\n\t\t\t\tx: x,\n\t\t\t\ty: y,\n\t\t\t\tskip: custom.skip || isNaN(x) || isNaN(y),\n\t\t\t\t// Appearance\n\t\t\t\tradius: custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, pointOptions.radius),\n\t\t\t\tpointStyle: custom.pointStyle || helpers.valueAtIndexOrDefault(dataset.pointStyle, index, pointOptions.pointStyle),\n\t\t\t\tbackgroundColor: me.getPointBackgroundColor(point, index),\n\t\t\t\tborderColor: me.getPointBorderColor(point, index),\n\t\t\t\tborderWidth: me.getPointBorderWidth(point, index),\n\t\t\t\ttension: meta.dataset._model ? meta.dataset._model.tension : 0,\n\t\t\t\tsteppedLine: meta.dataset._model ? meta.dataset._model.steppedLine : false,\n\t\t\t\t// Tooltip\n\t\t\t\thitRadius: custom.hitRadius || helpers.valueAtIndexOrDefault(dataset.pointHitRadius, index, pointOptions.hitRadius)\n\t\t\t};\n\t\t},\n\n\t\tcalculatePointY: function(value, index, datasetIndex) {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar yScale = me.getScaleForId(meta.yAxisID);\n\t\t\tvar sumPos = 0;\n\t\t\tvar sumNeg = 0;\n\t\t\tvar i, ds, dsMeta;\n\n\t\t\tif (yScale.options.stacked) {\n\t\t\t\tfor (i = 0; i < datasetIndex; i++) {\n\t\t\t\t\tds = chart.data.datasets[i];\n\t\t\t\t\tdsMeta = chart.getDatasetMeta(i);\n\t\t\t\t\tif (dsMeta.type === 'line' && dsMeta.yAxisID === yScale.id && chart.isDatasetVisible(i)) {\n\t\t\t\t\t\tvar stackedRightValue = Number(yScale.getRightValue(ds.data[index]));\n\t\t\t\t\t\tif (stackedRightValue < 0) {\n\t\t\t\t\t\t\tsumNeg += stackedRightValue || 0;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsumPos += stackedRightValue || 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar rightValue = Number(yScale.getRightValue(value));\n\t\t\t\tif (rightValue < 0) {\n\t\t\t\t\treturn yScale.getPixelForValue(sumNeg + rightValue);\n\t\t\t\t}\n\t\t\t\treturn yScale.getPixelForValue(sumPos + rightValue);\n\t\t\t}\n\n\t\t\treturn yScale.getPixelForValue(value);\n\t\t},\n\n\t\tupdateBezierControlPoints: function() {\n\t\t\tvar me = this;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar area = me.chart.chartArea;\n\t\t\tvar points = (meta.data || []);\n\t\t\tvar i, ilen, point, model, controlPoints;\n\n\t\t\t// Only consider points that are drawn in case the spanGaps option is used\n\t\t\tif (meta.dataset._model.spanGaps) {\n\t\t\t\tpoints = points.filter(function(pt) {\n\t\t\t\t\treturn !pt._model.skip;\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction capControlPoint(pt, min, max) {\n\t\t\t\treturn Math.max(Math.min(pt, max), min);\n\t\t\t}\n\n\t\t\tif (meta.dataset._model.cubicInterpolationMode === 'monotone') {\n\t\t\t\thelpers.splineCurveMonotone(points);\n\t\t\t} else {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tpoint = points[i];\n\t\t\t\t\tmodel = point._model;\n\t\t\t\t\tcontrolPoints = helpers.splineCurve(\n\t\t\t\t\t\thelpers.previousItem(points, i)._model,\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\thelpers.nextItem(points, i)._model,\n\t\t\t\t\t\tmeta.dataset._model.tension\n\t\t\t\t\t);\n\t\t\t\t\tmodel.controlPointPreviousX = controlPoints.previous.x;\n\t\t\t\t\tmodel.controlPointPreviousY = controlPoints.previous.y;\n\t\t\t\t\tmodel.controlPointNextX = controlPoints.next.x;\n\t\t\t\t\tmodel.controlPointNextY = controlPoints.next.y;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (me.chart.options.elements.line.capBezierPoints) {\n\t\t\t\tfor (i = 0, ilen = points.length; i < ilen; ++i) {\n\t\t\t\t\tmodel = points[i]._model;\n\t\t\t\t\tmodel.controlPointPreviousX = capControlPoint(model.controlPointPreviousX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointPreviousY = capControlPoint(model.controlPointPreviousY, area.top, area.bottom);\n\t\t\t\t\tmodel.controlPointNextX = capControlPoint(model.controlPointNextX, area.left, area.right);\n\t\t\t\t\tmodel.controlPointNextY = capControlPoint(model.controlPointNextY, area.top, area.bottom);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tdraw: function() {\n\t\t\tvar me = this;\n\t\t\tvar chart = me.chart;\n\t\t\tvar meta = me.getMeta();\n\t\t\tvar points = meta.data || [];\n\t\t\tvar area = chart.chartArea;\n\t\t\tvar ilen = points.length;\n\t\t\tvar i = 0;\n\n\t\t\thelpers.canvas.clipArea(chart.ctx, area);\n\n\t\t\tif (lineEnabled(me.getDataset(), chart.options)) {\n\t\t\t\tmeta.dataset.draw();\n\t\t\t}\n\n\t\t\thelpers.canvas.unclipArea(chart.ctx);\n\n\t\t\t// Draw the points\n\t\t\tfor (; i < ilen; ++i) {\n\t\t\t\tpoints[i].draw(area);\n\t\t\t}\n\t\t},\n\n\t\tsetHoverStyle: function(point) {\n\t\t\t// Point\n\t\t\tvar dataset = this.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\tmodel.radius = custom.hoverRadius || helpers.valueAtIndexOrDefault(dataset.pointHoverRadius, index, this.chart.options.elements.point.hoverRadius);\n\t\t\tmodel.backgroundColor = custom.hoverBackgroundColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBackgroundColor, index, helpers.getHoverColor(model.backgroundColor));\n\t\t\tmodel.borderColor = custom.hoverBorderColor || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderColor, index, helpers.getHoverColor(model.borderColor));\n\t\t\tmodel.borderWidth = custom.hoverBorderWidth || helpers.valueAtIndexOrDefault(dataset.pointHoverBorderWidth, index, model.borderWidth);\n\t\t},\n\n\t\tremoveHoverStyle: function(point) {\n\t\t\tvar me = this;\n\t\t\tvar dataset = me.chart.data.datasets[point._datasetIndex];\n\t\t\tvar index = point._index;\n\t\t\tvar custom = point.custom || {};\n\t\t\tvar model = point._model;\n\n\t\t\t// Compatibility: If the properties are defined with only the old name, use those values\n\t\t\tif ((dataset.radius !== undefined) && (dataset.pointRadius === undefined)) {\n\t\t\t\tdataset.pointRadius = dataset.radius;\n\t\t\t}\n\n\t\t\tmodel.radius = custom.radius || helpers.valueAtIndexOrDefault(dataset.pointRadius, index, me.chart.options.elements.point.radius);\n\t\t\tmodel.backgroundColor = me.getPointBackgroundColor(point, index);\n\t\t\tmodel.borderColor = me.getPointBorderColor(point, index);\n\t\t\tmodel.borderWidth = me.getPointBorderWidth(point, index);\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}