{"ast":null,"code":"'use strict';\n\nvar defaults = require('./core.defaults');\n\nvar Element = require('./core.element');\n\nvar helpers = require('../helpers/index');\n\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n  display: true,\n  position: 'left',\n  offset: false,\n  // grid line settings\n  gridLines: {\n    display: true,\n    color: 'rgba(0, 0, 0, 0.1)',\n    lineWidth: 1,\n    drawBorder: true,\n    drawOnChartArea: true,\n    drawTicks: true,\n    tickMarkLength: 10,\n    zeroLineWidth: 1,\n    zeroLineColor: 'rgba(0,0,0,0.25)',\n    zeroLineBorderDash: [],\n    zeroLineBorderDashOffset: 0.0,\n    offsetGridLines: false,\n    borderDash: [],\n    borderDashOffset: 0.0\n  },\n  // scale label\n  scaleLabel: {\n    // display property\n    display: false,\n    // actual label\n    labelString: '',\n    // line height\n    lineHeight: 1.2,\n    // top/bottom padding\n    padding: {\n      top: 4,\n      bottom: 4\n    }\n  },\n  // label settings\n  ticks: {\n    beginAtZero: false,\n    minRotation: 0,\n    maxRotation: 50,\n    mirror: false,\n    padding: 0,\n    reverse: false,\n    display: true,\n    autoSkip: true,\n    autoSkipPadding: 0,\n    labelOffset: 0,\n    // We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n    callback: Ticks.formatters.values,\n    minor: {},\n    major: {}\n  }\n});\n\nfunction labelsFromTicks(ticks) {\n  var labels = [];\n  var i, ilen;\n\n  for (i = 0, ilen = ticks.length; i < ilen; ++i) {\n    labels.push(ticks[i].label);\n  }\n\n  return labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n  var lineValue = scale.getPixelForTick(index);\n\n  if (offsetGridLines) {\n    if (index === 0) {\n      lineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n    } else {\n      lineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n    }\n  }\n\n  return lineValue;\n}\n\nmodule.exports = function (Chart) {\n  function computeTextSize(context, tick, font) {\n    return helpers.isArray(tick) ? helpers.longestText(context, font, tick) : context.measureText(tick).width;\n  }\n\n  function parseFontOptions(options) {\n    var valueOrDefault = helpers.valueOrDefault;\n    var globalDefaults = defaults.global;\n    var size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n    var style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n    var family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n    return {\n      size: size,\n      style: style,\n      family: family,\n      font: helpers.fontString(size, style, family)\n    };\n  }\n\n  function parseLineHeight(options) {\n    return helpers.options.toLineHeight(helpers.valueOrDefault(options.lineHeight, 1.2), helpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n  }\n\n  Chart.Scale = Element.extend({\n    /**\n     * Get the padding needed for the scale\n     * @method getPadding\n     * @private\n     * @returns {Padding} the necessary padding\n     */\n    getPadding: function getPadding() {\n      var me = this;\n      return {\n        left: me.paddingLeft || 0,\n        top: me.paddingTop || 0,\n        right: me.paddingRight || 0,\n        bottom: me.paddingBottom || 0\n      };\n    },\n\n    /**\n     * Returns the scale tick objects ({label, major})\n     * @since 2.7\n     */\n    getTicks: function getTicks() {\n      return this._ticks;\n    },\n    // These methods are ordered by lifecyle. Utilities then follow.\n    // Any function defined here is inherited by all scale types.\n    // Any function can be extended by the scale type\n    mergeTicksOptions: function mergeTicksOptions() {\n      var ticks = this.options.ticks;\n\n      if (ticks.minor === false) {\n        ticks.minor = {\n          display: false\n        };\n      }\n\n      if (ticks.major === false) {\n        ticks.major = {\n          display: false\n        };\n      }\n\n      for (var key in ticks) {\n        if (key !== 'major' && key !== 'minor') {\n          if (typeof ticks.minor[key] === 'undefined') {\n            ticks.minor[key] = ticks[key];\n          }\n\n          if (typeof ticks.major[key] === 'undefined') {\n            ticks.major[key] = ticks[key];\n          }\n        }\n      }\n    },\n    beforeUpdate: function beforeUpdate() {\n      helpers.callback(this.options.beforeUpdate, [this]);\n    },\n    update: function update(maxWidth, maxHeight, margins) {\n      var me = this;\n      var i, ilen, labels, label, ticks, tick; // Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\n      me.beforeUpdate(); // Absorb the master measurements\n\n      me.maxWidth = maxWidth;\n      me.maxHeight = maxHeight;\n      me.margins = helpers.extend({\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n      }, margins);\n      me.longestTextCache = me.longestTextCache || {}; // Dimensions\n\n      me.beforeSetDimensions();\n      me.setDimensions();\n      me.afterSetDimensions(); // Data min/max\n\n      me.beforeDataLimits();\n      me.determineDataLimits();\n      me.afterDataLimits(); // Ticks - `this.ticks` is now DEPRECATED!\n      // Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n      // and must not be accessed directly from outside this class. `this.ticks` being\n      // around for long time and not marked as private, we can't change its structure\n      // without unexpected breaking changes. If you need to access the scale ticks,\n      // use scale.getTicks() instead.\n\n      me.beforeBuildTicks(); // New implementations should return an array of objects but for BACKWARD COMPAT,\n      // we still support no return (`this.ticks` internally set by calling this method).\n\n      ticks = me.buildTicks() || [];\n      me.afterBuildTicks();\n      me.beforeTickToLabelConversion(); // New implementations should return the formatted tick labels but for BACKWARD\n      // COMPAT, we still support no return (`this.ticks` internally changed by calling\n      // this method and supposed to contain only string values).\n\n      labels = me.convertTicksToLabels(ticks) || me.ticks;\n      me.afterTickToLabelConversion();\n      me.ticks = labels; // BACKWARD COMPATIBILITY\n      // IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n      // BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\n      for (i = 0, ilen = labels.length; i < ilen; ++i) {\n        label = labels[i];\n        tick = ticks[i];\n\n        if (!tick) {\n          ticks.push(tick = {\n            label: label,\n            major: false\n          });\n        } else {\n          tick.label = label;\n        }\n      }\n\n      me._ticks = ticks; // Tick Rotation\n\n      me.beforeCalculateTickRotation();\n      me.calculateTickRotation();\n      me.afterCalculateTickRotation(); // Fit\n\n      me.beforeFit();\n      me.fit();\n      me.afterFit(); //\n\n      me.afterUpdate();\n      return me.minSize;\n    },\n    afterUpdate: function afterUpdate() {\n      helpers.callback(this.options.afterUpdate, [this]);\n    },\n    //\n    beforeSetDimensions: function beforeSetDimensions() {\n      helpers.callback(this.options.beforeSetDimensions, [this]);\n    },\n    setDimensions: function setDimensions() {\n      var me = this; // Set the unconstrained dimension before label rotation\n\n      if (me.isHorizontal()) {\n        // Reset position before calculating rotation\n        me.width = me.maxWidth;\n        me.left = 0;\n        me.right = me.width;\n      } else {\n        me.height = me.maxHeight; // Reset position before calculating rotation\n\n        me.top = 0;\n        me.bottom = me.height;\n      } // Reset padding\n\n\n      me.paddingLeft = 0;\n      me.paddingTop = 0;\n      me.paddingRight = 0;\n      me.paddingBottom = 0;\n    },\n    afterSetDimensions: function afterSetDimensions() {\n      helpers.callback(this.options.afterSetDimensions, [this]);\n    },\n    // Data limits\n    beforeDataLimits: function beforeDataLimits() {\n      helpers.callback(this.options.beforeDataLimits, [this]);\n    },\n    determineDataLimits: helpers.noop,\n    afterDataLimits: function afterDataLimits() {\n      helpers.callback(this.options.afterDataLimits, [this]);\n    },\n    //\n    beforeBuildTicks: function beforeBuildTicks() {\n      helpers.callback(this.options.beforeBuildTicks, [this]);\n    },\n    buildTicks: helpers.noop,\n    afterBuildTicks: function afterBuildTicks() {\n      helpers.callback(this.options.afterBuildTicks, [this]);\n    },\n    beforeTickToLabelConversion: function beforeTickToLabelConversion() {\n      helpers.callback(this.options.beforeTickToLabelConversion, [this]);\n    },\n    convertTicksToLabels: function convertTicksToLabels() {\n      var me = this; // Convert ticks to strings\n\n      var tickOpts = me.options.ticks;\n      me.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n    },\n    afterTickToLabelConversion: function afterTickToLabelConversion() {\n      helpers.callback(this.options.afterTickToLabelConversion, [this]);\n    },\n    //\n    beforeCalculateTickRotation: function beforeCalculateTickRotation() {\n      helpers.callback(this.options.beforeCalculateTickRotation, [this]);\n    },\n    calculateTickRotation: function calculateTickRotation() {\n      var me = this;\n      var context = me.ctx;\n      var tickOpts = me.options.ticks;\n      var labels = labelsFromTicks(me._ticks); // Get the width of each grid by calculating the difference\n      // between x offsets between 0 and 1.\n\n      var tickFont = parseFontOptions(tickOpts);\n      context.font = tickFont.font;\n      var labelRotation = tickOpts.minRotation || 0;\n\n      if (labels.length && me.options.display && me.isHorizontal()) {\n        var originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n        var labelWidth = originalLabelWidth;\n        var cosRotation, sinRotation; // Allow 3 pixels x2 padding either side for label readability\n\n        var tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6; // Max label rotation can be set or default to 90 - also act as a loop counter\n\n        while (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n          var angleRadians = helpers.toRadians(labelRotation);\n          cosRotation = Math.cos(angleRadians);\n          sinRotation = Math.sin(angleRadians);\n\n          if (sinRotation * originalLabelWidth > me.maxHeight) {\n            // go back one step\n            labelRotation--;\n            break;\n          }\n\n          labelRotation++;\n          labelWidth = cosRotation * originalLabelWidth;\n        }\n      }\n\n      me.labelRotation = labelRotation;\n    },\n    afterCalculateTickRotation: function afterCalculateTickRotation() {\n      helpers.callback(this.options.afterCalculateTickRotation, [this]);\n    },\n    //\n    beforeFit: function beforeFit() {\n      helpers.callback(this.options.beforeFit, [this]);\n    },\n    fit: function fit() {\n      var me = this; // Reset\n\n      var minSize = me.minSize = {\n        width: 0,\n        height: 0\n      };\n      var labels = labelsFromTicks(me._ticks);\n      var opts = me.options;\n      var tickOpts = opts.ticks;\n      var scaleLabelOpts = opts.scaleLabel;\n      var gridLineOpts = opts.gridLines;\n      var display = opts.display;\n      var isHorizontal = me.isHorizontal();\n      var tickFont = parseFontOptions(tickOpts);\n      var tickMarkLength = opts.gridLines.tickMarkLength; // Width\n\n      if (isHorizontal) {\n        // subtract the margins to line up with the chartArea if we are a full width scale\n        minSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n      } else {\n        minSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n      } // height\n\n\n      if (isHorizontal) {\n        minSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n      } else {\n        minSize.height = me.maxHeight; // fill all the height\n      } // Are we showing a title for the scale?\n\n\n      if (scaleLabelOpts.display && display) {\n        var scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n        var scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n        var deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n        if (isHorizontal) {\n          minSize.height += deltaHeight;\n        } else {\n          minSize.width += deltaHeight;\n        }\n      } // Don't bother fitting the ticks if we are not showing them\n\n\n      if (tickOpts.display && display) {\n        var largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n        var tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n        var lineSpace = tickFont.size * 0.5;\n        var tickPadding = me.options.ticks.padding;\n\n        if (isHorizontal) {\n          // A horizontal axis is more constrained by the height.\n          me.longestLabelWidth = largestTextWidth;\n          var angleRadians = helpers.toRadians(me.labelRotation);\n          var cosRotation = Math.cos(angleRadians);\n          var sinRotation = Math.sin(angleRadians); // TODO - improve this calculation\n\n          var labelHeight = sinRotation * largestTextWidth + tickFont.size * tallestLabelHeightInLines + lineSpace * (tallestLabelHeightInLines - 1) + lineSpace; // padding\n\n          minSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n          me.ctx.font = tickFont.font;\n          var firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n          var lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font); // Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n          // which means that the right padding is dominated by the font height\n\n          if (me.labelRotation !== 0) {\n            me.paddingLeft = opts.position === 'bottom' ? cosRotation * firstLabelWidth + 3 : cosRotation * lineSpace + 3; // add 3 px to move away from canvas edges\n\n            me.paddingRight = opts.position === 'bottom' ? cosRotation * lineSpace + 3 : cosRotation * lastLabelWidth + 3;\n          } else {\n            me.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\n            me.paddingRight = lastLabelWidth / 2 + 3;\n          }\n        } else {\n          // A vertical axis is more constrained by the width. Labels are the\n          // dominant factor here, so get that length first and account for padding\n          if (tickOpts.mirror) {\n            largestTextWidth = 0;\n          } else {\n            // use lineSpace for consistency with horizontal axis\n            // tickPadding is not implemented for horizontal\n            largestTextWidth += tickPadding + lineSpace;\n          }\n\n          minSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n          me.paddingTop = tickFont.size / 2;\n          me.paddingBottom = tickFont.size / 2;\n        }\n      }\n\n      me.handleMargins();\n      me.width = minSize.width;\n      me.height = minSize.height;\n    },\n\n    /**\n     * Handle margins and padding interactions\n     * @private\n     */\n    handleMargins: function handleMargins() {\n      var me = this;\n\n      if (me.margins) {\n        me.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n        me.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n        me.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n        me.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n      }\n    },\n    afterFit: function afterFit() {\n      helpers.callback(this.options.afterFit, [this]);\n    },\n    // Shared Methods\n    isHorizontal: function isHorizontal() {\n      return this.options.position === 'top' || this.options.position === 'bottom';\n    },\n    isFullWidth: function isFullWidth() {\n      return this.options.fullWidth;\n    },\n    // Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n    getRightValue: function getRightValue(rawValue) {\n      // Null and undefined values first\n      if (helpers.isNullOrUndef(rawValue)) {\n        return NaN;\n      } // isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\n\n      if (typeof rawValue === 'number' && !isFinite(rawValue)) {\n        return NaN;\n      } // If it is in fact an object, dive in one more level\n\n\n      if (rawValue) {\n        if (this.isHorizontal()) {\n          if (rawValue.x !== undefined) {\n            return this.getRightValue(rawValue.x);\n          }\n        } else if (rawValue.y !== undefined) {\n          return this.getRightValue(rawValue.y);\n        }\n      } // Value is good, return it\n\n\n      return rawValue;\n    },\n\n    /**\n     * Used to get the value to display in the tooltip for the data at the given index\n     * @param index\n     * @param datasetIndex\n     */\n    getLabelForIndex: helpers.noop,\n\n    /**\n     * Returns the location of the given data point. Value can either be an index or a numerical value\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     * @param value\n     * @param index\n     * @param datasetIndex\n     */\n    getPixelForValue: helpers.noop,\n\n    /**\n     * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     * @param pixel\n     */\n    getValueForPixel: helpers.noop,\n\n    /**\n     * Returns the location of the tick at the given index\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     */\n    getPixelForTick: function getPixelForTick(index) {\n      var me = this;\n      var offset = me.options.offset;\n\n      if (me.isHorizontal()) {\n        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n        var tickWidth = innerWidth / Math.max(me._ticks.length - (offset ? 0 : 1), 1);\n        var pixel = tickWidth * index + me.paddingLeft;\n\n        if (offset) {\n          pixel += tickWidth / 2;\n        }\n\n        var finalVal = me.left + Math.round(pixel);\n        finalVal += me.isFullWidth() ? me.margins.left : 0;\n        return finalVal;\n      }\n\n      var innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n      return me.top + index * (innerHeight / (me._ticks.length - 1));\n    },\n\n    /**\n     * Utility for getting the pixel location of a percentage of scale\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     */\n    getPixelForDecimal: function getPixelForDecimal(decimal) {\n      var me = this;\n\n      if (me.isHorizontal()) {\n        var innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n        var valueOffset = innerWidth * decimal + me.paddingLeft;\n        var finalVal = me.left + Math.round(valueOffset);\n        finalVal += me.isFullWidth() ? me.margins.left : 0;\n        return finalVal;\n      }\n\n      return me.top + decimal * me.height;\n    },\n\n    /**\n     * Returns the pixel for the minimum chart value\n     * The coordinate (0, 0) is at the upper-left corner of the canvas\n     */\n    getBasePixel: function getBasePixel() {\n      return this.getPixelForValue(this.getBaseValue());\n    },\n    getBaseValue: function getBaseValue() {\n      var me = this;\n      var min = me.min;\n      var max = me.max;\n      return me.beginAtZero ? 0 : min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;\n    },\n\n    /**\n     * Returns a subset of ticks to be plotted to avoid overlapping labels.\n     * @private\n     */\n    _autoSkip: function _autoSkip(ticks) {\n      var skipRatio;\n      var me = this;\n      var isHorizontal = me.isHorizontal();\n      var optionTicks = me.options.ticks.minor;\n      var tickCount = ticks.length;\n      var labelRotationRadians = helpers.toRadians(me.labelRotation);\n      var cosRotation = Math.cos(labelRotationRadians);\n      var longestRotatedLabel = me.longestLabelWidth * cosRotation;\n      var result = [];\n      var i, tick, shouldSkip; // figure out the maximum number of gridlines to show\n\n      var maxTicks;\n\n      if (optionTicks.maxTicksLimit) {\n        maxTicks = optionTicks.maxTicksLimit;\n      }\n\n      if (isHorizontal) {\n        skipRatio = false;\n\n        if ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > me.width - (me.paddingLeft + me.paddingRight)) {\n          skipRatio = 1 + Math.floor((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount / (me.width - (me.paddingLeft + me.paddingRight)));\n        } // if they defined a max number of optionTicks,\n        // increase skipRatio until that number is met\n\n\n        if (maxTicks && tickCount > maxTicks) {\n          skipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n        }\n      }\n\n      for (i = 0; i < tickCount; i++) {\n        tick = ticks[i]; // Since we always show the last tick,we need may need to hide the last shown one before\n\n        shouldSkip = skipRatio > 1 && i % skipRatio > 0 || i % skipRatio === 0 && i + skipRatio >= tickCount;\n\n        if (shouldSkip && i !== tickCount - 1) {\n          // leave tick in place but make sure it's not displayed (#4635)\n          delete tick.label;\n        }\n\n        result.push(tick);\n      }\n\n      return result;\n    },\n    // Actually draw the scale on the canvas\n    // @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n    draw: function draw(chartArea) {\n      var me = this;\n      var options = me.options;\n\n      if (!options.display) {\n        return;\n      }\n\n      var context = me.ctx;\n      var globalDefaults = defaults.global;\n      var optionTicks = options.ticks.minor;\n      var optionMajorTicks = options.ticks.major || optionTicks;\n      var gridLines = options.gridLines;\n      var scaleLabel = options.scaleLabel;\n      var isRotated = me.labelRotation !== 0;\n      var isHorizontal = me.isHorizontal();\n      var ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n      var tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n      var tickFont = parseFontOptions(optionTicks);\n      var majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n      var majorTickFont = parseFontOptions(optionMajorTicks);\n      var tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n      var scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n      var scaleLabelFont = parseFontOptions(scaleLabel);\n      var scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n      var labelRotationRadians = helpers.toRadians(me.labelRotation);\n      var itemsToDraw = [];\n      var axisWidth = me.options.gridLines.lineWidth;\n      var xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;\n      var xTickEnd = options.position === 'right' ? me.right + tl : me.right;\n      var yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n      var yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n      helpers.each(ticks, function (tick, index) {\n        // autoskipper skipped this tick (#4635)\n        if (helpers.isNullOrUndef(tick.label)) {\n          return;\n        }\n\n        var label = tick.label;\n        var lineWidth, lineColor, borderDash, borderDashOffset;\n\n        if (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n          // Draw the first index specially\n          lineWidth = gridLines.zeroLineWidth;\n          lineColor = gridLines.zeroLineColor;\n          borderDash = gridLines.zeroLineBorderDash;\n          borderDashOffset = gridLines.zeroLineBorderDashOffset;\n        } else {\n          lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n          lineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n          borderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n          borderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n        } // Common properties\n\n\n        var tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n        var textAlign = 'middle';\n        var textBaseline = 'middle';\n        var tickPadding = optionTicks.padding;\n\n        if (isHorizontal) {\n          var labelYOffset = tl + tickPadding;\n\n          if (options.position === 'bottom') {\n            // bottom\n            textBaseline = !isRotated ? 'top' : 'middle';\n            textAlign = !isRotated ? 'center' : 'right';\n            labelY = me.top + labelYOffset;\n          } else {\n            // top\n            textBaseline = !isRotated ? 'bottom' : 'middle';\n            textAlign = !isRotated ? 'center' : 'left';\n            labelY = me.bottom - labelYOffset;\n          }\n\n          var xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\n          if (xLineValue < me.left) {\n            lineColor = 'rgba(0,0,0,0)';\n          }\n\n          xLineValue += helpers.aliasPixel(lineWidth);\n          labelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n          tx1 = tx2 = x1 = x2 = xLineValue;\n          ty1 = yTickStart;\n          ty2 = yTickEnd;\n          y1 = chartArea.top;\n          y2 = chartArea.bottom + axisWidth;\n        } else {\n          var isLeft = options.position === 'left';\n          var labelXOffset;\n\n          if (optionTicks.mirror) {\n            textAlign = isLeft ? 'left' : 'right';\n            labelXOffset = tickPadding;\n          } else {\n            textAlign = isLeft ? 'right' : 'left';\n            labelXOffset = tl + tickPadding;\n          }\n\n          labelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n          var yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\n          if (yLineValue < me.top) {\n            lineColor = 'rgba(0,0,0,0)';\n          }\n\n          yLineValue += helpers.aliasPixel(lineWidth);\n          labelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n          tx1 = xTickStart;\n          tx2 = xTickEnd;\n          x1 = chartArea.left;\n          x2 = chartArea.right + axisWidth;\n          ty1 = ty2 = y1 = y2 = yLineValue;\n        }\n\n        itemsToDraw.push({\n          tx1: tx1,\n          ty1: ty1,\n          tx2: tx2,\n          ty2: ty2,\n          x1: x1,\n          y1: y1,\n          x2: x2,\n          y2: y2,\n          labelX: labelX,\n          labelY: labelY,\n          glWidth: lineWidth,\n          glColor: lineColor,\n          glBorderDash: borderDash,\n          glBorderDashOffset: borderDashOffset,\n          rotation: -1 * labelRotationRadians,\n          label: label,\n          major: tick.major,\n          textBaseline: textBaseline,\n          textAlign: textAlign\n        });\n      }); // Draw all of the tick labels, tick marks, and grid lines at the correct places\n\n      helpers.each(itemsToDraw, function (itemToDraw) {\n        if (gridLines.display) {\n          context.save();\n          context.lineWidth = itemToDraw.glWidth;\n          context.strokeStyle = itemToDraw.glColor;\n\n          if (context.setLineDash) {\n            context.setLineDash(itemToDraw.glBorderDash);\n            context.lineDashOffset = itemToDraw.glBorderDashOffset;\n          }\n\n          context.beginPath();\n\n          if (gridLines.drawTicks) {\n            context.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n            context.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n          }\n\n          if (gridLines.drawOnChartArea) {\n            context.moveTo(itemToDraw.x1, itemToDraw.y1);\n            context.lineTo(itemToDraw.x2, itemToDraw.y2);\n          }\n\n          context.stroke();\n          context.restore();\n        }\n\n        if (optionTicks.display) {\n          // Make sure we draw text in the correct color and font\n          context.save();\n          context.translate(itemToDraw.labelX, itemToDraw.labelY);\n          context.rotate(itemToDraw.rotation);\n          context.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n          context.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n          context.textBaseline = itemToDraw.textBaseline;\n          context.textAlign = itemToDraw.textAlign;\n          var label = itemToDraw.label;\n\n          if (helpers.isArray(label)) {\n            var lineCount = label.length;\n            var lineHeight = tickFont.size * 1.5;\n            var y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n            for (var i = 0; i < lineCount; ++i) {\n              // We just make sure the multiline element is a string here..\n              context.fillText('' + label[i], 0, y); // apply same lineSpacing as calculated @ L#320\n\n              y += lineHeight;\n            }\n          } else {\n            context.fillText(label, 0, 0);\n          }\n\n          context.restore();\n        }\n      });\n\n      if (scaleLabel.display) {\n        // Draw the scale label\n        var scaleLabelX;\n        var scaleLabelY;\n        var rotation = 0;\n        var halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n        if (isHorizontal) {\n          scaleLabelX = me.left + (me.right - me.left) / 2; // midpoint of the width\n\n          scaleLabelY = options.position === 'bottom' ? me.bottom - halfLineHeight - scaleLabelPadding.bottom : me.top + halfLineHeight + scaleLabelPadding.top;\n        } else {\n          var isLeft = options.position === 'left';\n          scaleLabelX = isLeft ? me.left + halfLineHeight + scaleLabelPadding.top : me.right - halfLineHeight - scaleLabelPadding.top;\n          scaleLabelY = me.top + (me.bottom - me.top) / 2;\n          rotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n        }\n\n        context.save();\n        context.translate(scaleLabelX, scaleLabelY);\n        context.rotate(rotation);\n        context.textAlign = 'center';\n        context.textBaseline = 'middle';\n        context.fillStyle = scaleLabelFontColor; // render in correct colour\n\n        context.font = scaleLabelFont.font;\n        context.fillText(scaleLabel.labelString, 0, 0);\n        context.restore();\n      }\n\n      if (gridLines.drawBorder) {\n        // Draw the line at the edge of the axis\n        context.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n        context.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n        var x1 = me.left;\n        var x2 = me.right + axisWidth;\n        var y1 = me.top;\n        var y2 = me.bottom + axisWidth;\n        var aliasPixel = helpers.aliasPixel(context.lineWidth);\n\n        if (isHorizontal) {\n          y1 = y2 = options.position === 'top' ? me.bottom : me.top;\n          y1 += aliasPixel;\n          y2 += aliasPixel;\n        } else {\n          x1 = x2 = options.position === 'left' ? me.right : me.left;\n          x1 += aliasPixel;\n          x2 += aliasPixel;\n        }\n\n        context.beginPath();\n        context.moveTo(x1, y1);\n        context.lineTo(x2, y2);\n        context.stroke();\n      }\n    }\n  });\n};","map":{"version":3,"sources":["/home/mohamed/projects/ESense/react-ui/node_modules/chart.js/src/core/core.scale.js"],"names":["defaults","require","Element","helpers","Ticks","_set","display","position","offset","gridLines","color","lineWidth","drawBorder","drawOnChartArea","drawTicks","tickMarkLength","zeroLineWidth","zeroLineColor","zeroLineBorderDash","zeroLineBorderDashOffset","offsetGridLines","borderDash","borderDashOffset","scaleLabel","labelString","lineHeight","padding","top","bottom","ticks","beginAtZero","minRotation","maxRotation","mirror","reverse","autoSkip","autoSkipPadding","labelOffset","callback","formatters","values","minor","major","labelsFromTicks","labels","i","ilen","length","push","label","getLineValue","scale","index","lineValue","getPixelForTick","module","exports","Chart","computeTextSize","context","tick","font","isArray","longestText","measureText","width","parseFontOptions","options","valueOrDefault","globalDefaults","global","size","fontSize","defaultFontSize","style","fontStyle","defaultFontStyle","family","fontFamily","defaultFontFamily","fontString","parseLineHeight","toLineHeight","Scale","extend","getPadding","me","left","paddingLeft","paddingTop","right","paddingRight","paddingBottom","getTicks","_ticks","mergeTicksOptions","key","beforeUpdate","update","maxWidth","maxHeight","margins","longestTextCache","beforeSetDimensions","setDimensions","afterSetDimensions","beforeDataLimits","determineDataLimits","afterDataLimits","beforeBuildTicks","buildTicks","afterBuildTicks","beforeTickToLabelConversion","convertTicksToLabels","afterTickToLabelConversion","beforeCalculateTickRotation","calculateTickRotation","afterCalculateTickRotation","beforeFit","fit","afterFit","afterUpdate","minSize","isHorizontal","height","noop","tickOpts","map","userCallback","ctx","tickFont","labelRotation","originalLabelWidth","labelWidth","cosRotation","sinRotation","tickWidth","angleRadians","toRadians","Math","cos","sin","opts","scaleLabelOpts","gridLineOpts","isFullWidth","scaleLabelLineHeight","scaleLabelPadding","toPadding","deltaHeight","largestTextWidth","tallestLabelHeightInLines","numberOfLabelLines","lineSpace","tickPadding","longestLabelWidth","labelHeight","min","firstLabelWidth","lastLabelWidth","handleMargins","max","fullWidth","getRightValue","rawValue","isNullOrUndef","NaN","isFinite","x","undefined","y","getLabelForIndex","getPixelForValue","getValueForPixel","innerWidth","pixel","finalVal","round","innerHeight","getPixelForDecimal","decimal","valueOffset","getBasePixel","getBaseValue","_autoSkip","skipRatio","optionTicks","tickCount","labelRotationRadians","longestRotatedLabel","result","shouldSkip","maxTicks","maxTicksLimit","floor","draw","chartArea","optionMajorTicks","isRotated","tickFontColor","fontColor","defaultFontColor","majorTickFontColor","majorTickFont","tl","scaleLabelFontColor","scaleLabelFont","itemsToDraw","axisWidth","xTickStart","xTickEnd","yTickStart","yTickEnd","each","lineColor","zeroLineIndex","valueAtIndexOrDefault","tx1","ty1","tx2","ty2","x1","y1","x2","y2","labelX","labelY","textAlign","textBaseline","labelYOffset","xLineValue","aliasPixel","isLeft","labelXOffset","yLineValue","glWidth","glColor","glBorderDash","glBorderDashOffset","rotation","itemToDraw","save","strokeStyle","setLineDash","lineDashOffset","beginPath","moveTo","lineTo","stroke","restore","translate","rotate","fillStyle","lineCount","fillText","scaleLabelX","scaleLabelY","halfLineHeight","PI"],"mappings":"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","sourcesContent":["'use strict';\n\nvar defaults = require('./core.defaults');\nvar Element = require('./core.element');\nvar helpers = require('../helpers/index');\nvar Ticks = require('./core.ticks');\n\ndefaults._set('scale', {\n\tdisplay: true,\n\tposition: 'left',\n\toffset: false,\n\n\t// grid line settings\n\tgridLines: {\n\t\tdisplay: true,\n\t\tcolor: 'rgba(0, 0, 0, 0.1)',\n\t\tlineWidth: 1,\n\t\tdrawBorder: true,\n\t\tdrawOnChartArea: true,\n\t\tdrawTicks: true,\n\t\ttickMarkLength: 10,\n\t\tzeroLineWidth: 1,\n\t\tzeroLineColor: 'rgba(0,0,0,0.25)',\n\t\tzeroLineBorderDash: [],\n\t\tzeroLineBorderDashOffset: 0.0,\n\t\toffsetGridLines: false,\n\t\tborderDash: [],\n\t\tborderDashOffset: 0.0\n\t},\n\n\t// scale label\n\tscaleLabel: {\n\t\t// display property\n\t\tdisplay: false,\n\n\t\t// actual label\n\t\tlabelString: '',\n\n\t\t// line height\n\t\tlineHeight: 1.2,\n\n\t\t// top/bottom padding\n\t\tpadding: {\n\t\t\ttop: 4,\n\t\t\tbottom: 4\n\t\t}\n\t},\n\n\t// label settings\n\tticks: {\n\t\tbeginAtZero: false,\n\t\tminRotation: 0,\n\t\tmaxRotation: 50,\n\t\tmirror: false,\n\t\tpadding: 0,\n\t\treverse: false,\n\t\tdisplay: true,\n\t\tautoSkip: true,\n\t\tautoSkipPadding: 0,\n\t\tlabelOffset: 0,\n\t\t// We pass through arrays to be rendered as multiline labels, we convert Others to strings here.\n\t\tcallback: Ticks.formatters.values,\n\t\tminor: {},\n\t\tmajor: {}\n\t}\n});\n\nfunction labelsFromTicks(ticks) {\n\tvar labels = [];\n\tvar i, ilen;\n\n\tfor (i = 0, ilen = ticks.length; i < ilen; ++i) {\n\t\tlabels.push(ticks[i].label);\n\t}\n\n\treturn labels;\n}\n\nfunction getLineValue(scale, index, offsetGridLines) {\n\tvar lineValue = scale.getPixelForTick(index);\n\n\tif (offsetGridLines) {\n\t\tif (index === 0) {\n\t\t\tlineValue -= (scale.getPixelForTick(1) - lineValue) / 2;\n\t\t} else {\n\t\t\tlineValue -= (lineValue - scale.getPixelForTick(index - 1)) / 2;\n\t\t}\n\t}\n\treturn lineValue;\n}\n\nmodule.exports = function(Chart) {\n\n\tfunction computeTextSize(context, tick, font) {\n\t\treturn helpers.isArray(tick) ?\n\t\t\thelpers.longestText(context, font, tick) :\n\t\t\tcontext.measureText(tick).width;\n\t}\n\n\tfunction parseFontOptions(options) {\n\t\tvar valueOrDefault = helpers.valueOrDefault;\n\t\tvar globalDefaults = defaults.global;\n\t\tvar size = valueOrDefault(options.fontSize, globalDefaults.defaultFontSize);\n\t\tvar style = valueOrDefault(options.fontStyle, globalDefaults.defaultFontStyle);\n\t\tvar family = valueOrDefault(options.fontFamily, globalDefaults.defaultFontFamily);\n\n\t\treturn {\n\t\t\tsize: size,\n\t\t\tstyle: style,\n\t\t\tfamily: family,\n\t\t\tfont: helpers.fontString(size, style, family)\n\t\t};\n\t}\n\n\tfunction parseLineHeight(options) {\n\t\treturn helpers.options.toLineHeight(\n\t\t\thelpers.valueOrDefault(options.lineHeight, 1.2),\n\t\t\thelpers.valueOrDefault(options.fontSize, defaults.global.defaultFontSize));\n\t}\n\n\tChart.Scale = Element.extend({\n\t\t/**\n\t\t * Get the padding needed for the scale\n\t\t * @method getPadding\n\t\t * @private\n\t\t * @returns {Padding} the necessary padding\n\t\t */\n\t\tgetPadding: function() {\n\t\t\tvar me = this;\n\t\t\treturn {\n\t\t\t\tleft: me.paddingLeft || 0,\n\t\t\t\ttop: me.paddingTop || 0,\n\t\t\t\tright: me.paddingRight || 0,\n\t\t\t\tbottom: me.paddingBottom || 0\n\t\t\t};\n\t\t},\n\n\t\t/**\n\t\t * Returns the scale tick objects ({label, major})\n\t\t * @since 2.7\n\t\t */\n\t\tgetTicks: function() {\n\t\t\treturn this._ticks;\n\t\t},\n\n\t\t// These methods are ordered by lifecyle. Utilities then follow.\n\t\t// Any function defined here is inherited by all scale types.\n\t\t// Any function can be extended by the scale type\n\n\t\tmergeTicksOptions: function() {\n\t\t\tvar ticks = this.options.ticks;\n\t\t\tif (ticks.minor === false) {\n\t\t\t\tticks.minor = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (ticks.major === false) {\n\t\t\t\tticks.major = {\n\t\t\t\t\tdisplay: false\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var key in ticks) {\n\t\t\t\tif (key !== 'major' && key !== 'minor') {\n\t\t\t\t\tif (typeof ticks.minor[key] === 'undefined') {\n\t\t\t\t\t\tticks.minor[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof ticks.major[key] === 'undefined') {\n\t\t\t\t\t\tticks.major[key] = ticks[key];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tbeforeUpdate: function() {\n\t\t\thelpers.callback(this.options.beforeUpdate, [this]);\n\t\t},\n\t\tupdate: function(maxWidth, maxHeight, margins) {\n\t\t\tvar me = this;\n\t\t\tvar i, ilen, labels, label, ticks, tick;\n\n\t\t\t// Update Lifecycle - Probably don't want to ever extend or overwrite this function ;)\n\t\t\tme.beforeUpdate();\n\n\t\t\t// Absorb the master measurements\n\t\t\tme.maxWidth = maxWidth;\n\t\t\tme.maxHeight = maxHeight;\n\t\t\tme.margins = helpers.extend({\n\t\t\t\tleft: 0,\n\t\t\t\tright: 0,\n\t\t\t\ttop: 0,\n\t\t\t\tbottom: 0\n\t\t\t}, margins);\n\t\t\tme.longestTextCache = me.longestTextCache || {};\n\n\t\t\t// Dimensions\n\t\t\tme.beforeSetDimensions();\n\t\t\tme.setDimensions();\n\t\t\tme.afterSetDimensions();\n\n\t\t\t// Data min/max\n\t\t\tme.beforeDataLimits();\n\t\t\tme.determineDataLimits();\n\t\t\tme.afterDataLimits();\n\n\t\t\t// Ticks - `this.ticks` is now DEPRECATED!\n\t\t\t// Internal ticks are now stored as objects in the PRIVATE `this._ticks` member\n\t\t\t// and must not be accessed directly from outside this class. `this.ticks` being\n\t\t\t// around for long time and not marked as private, we can't change its structure\n\t\t\t// without unexpected breaking changes. If you need to access the scale ticks,\n\t\t\t// use scale.getTicks() instead.\n\n\t\t\tme.beforeBuildTicks();\n\n\t\t\t// New implementations should return an array of objects but for BACKWARD COMPAT,\n\t\t\t// we still support no return (`this.ticks` internally set by calling this method).\n\t\t\tticks = me.buildTicks() || [];\n\n\t\t\tme.afterBuildTicks();\n\n\t\t\tme.beforeTickToLabelConversion();\n\n\t\t\t// New implementations should return the formatted tick labels but for BACKWARD\n\t\t\t// COMPAT, we still support no return (`this.ticks` internally changed by calling\n\t\t\t// this method and supposed to contain only string values).\n\t\t\tlabels = me.convertTicksToLabels(ticks) || me.ticks;\n\n\t\t\tme.afterTickToLabelConversion();\n\n\t\t\tme.ticks = labels;   // BACKWARD COMPATIBILITY\n\n\t\t\t// IMPORTANT: from this point, we consider that `this.ticks` will NEVER change!\n\n\t\t\t// BACKWARD COMPAT: synchronize `_ticks` with labels (so potentially `this.ticks`)\n\t\t\tfor (i = 0, ilen = labels.length; i < ilen; ++i) {\n\t\t\t\tlabel = labels[i];\n\t\t\t\ttick = ticks[i];\n\t\t\t\tif (!tick) {\n\t\t\t\t\tticks.push(tick = {\n\t\t\t\t\t\tlabel: label,\n\t\t\t\t\t\tmajor: false\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\ttick.label = label;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme._ticks = ticks;\n\n\t\t\t// Tick Rotation\n\t\t\tme.beforeCalculateTickRotation();\n\t\t\tme.calculateTickRotation();\n\t\t\tme.afterCalculateTickRotation();\n\t\t\t// Fit\n\t\t\tme.beforeFit();\n\t\t\tme.fit();\n\t\t\tme.afterFit();\n\t\t\t//\n\t\t\tme.afterUpdate();\n\n\t\t\treturn me.minSize;\n\n\t\t},\n\t\tafterUpdate: function() {\n\t\t\thelpers.callback(this.options.afterUpdate, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeSetDimensions: function() {\n\t\t\thelpers.callback(this.options.beforeSetDimensions, [this]);\n\t\t},\n\t\tsetDimensions: function() {\n\t\t\tvar me = this;\n\t\t\t// Set the unconstrained dimension before label rotation\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.width = me.maxWidth;\n\t\t\t\tme.left = 0;\n\t\t\t\tme.right = me.width;\n\t\t\t} else {\n\t\t\t\tme.height = me.maxHeight;\n\n\t\t\t\t// Reset position before calculating rotation\n\t\t\t\tme.top = 0;\n\t\t\t\tme.bottom = me.height;\n\t\t\t}\n\n\t\t\t// Reset padding\n\t\t\tme.paddingLeft = 0;\n\t\t\tme.paddingTop = 0;\n\t\t\tme.paddingRight = 0;\n\t\t\tme.paddingBottom = 0;\n\t\t},\n\t\tafterSetDimensions: function() {\n\t\t\thelpers.callback(this.options.afterSetDimensions, [this]);\n\t\t},\n\n\t\t// Data limits\n\t\tbeforeDataLimits: function() {\n\t\t\thelpers.callback(this.options.beforeDataLimits, [this]);\n\t\t},\n\t\tdetermineDataLimits: helpers.noop,\n\t\tafterDataLimits: function() {\n\t\t\thelpers.callback(this.options.afterDataLimits, [this]);\n\t\t},\n\n\t\t//\n\t\tbeforeBuildTicks: function() {\n\t\t\thelpers.callback(this.options.beforeBuildTicks, [this]);\n\t\t},\n\t\tbuildTicks: helpers.noop,\n\t\tafterBuildTicks: function() {\n\t\t\thelpers.callback(this.options.afterBuildTicks, [this]);\n\t\t},\n\n\t\tbeforeTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.beforeTickToLabelConversion, [this]);\n\t\t},\n\t\tconvertTicksToLabels: function() {\n\t\t\tvar me = this;\n\t\t\t// Convert ticks to strings\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tme.ticks = me.ticks.map(tickOpts.userCallback || tickOpts.callback, this);\n\t\t},\n\t\tafterTickToLabelConversion: function() {\n\t\t\thelpers.callback(this.options.afterTickToLabelConversion, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.beforeCalculateTickRotation, [this]);\n\t\t},\n\t\tcalculateTickRotation: function() {\n\t\t\tvar me = this;\n\t\t\tvar context = me.ctx;\n\t\t\tvar tickOpts = me.options.ticks;\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\t// Get the width of each grid by calculating the difference\n\t\t\t// between x offsets between 0 and 1.\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tcontext.font = tickFont.font;\n\n\t\t\tvar labelRotation = tickOpts.minRotation || 0;\n\n\t\t\tif (labels.length && me.options.display && me.isHorizontal()) {\n\t\t\t\tvar originalLabelWidth = helpers.longestText(context, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar labelWidth = originalLabelWidth;\n\t\t\t\tvar cosRotation, sinRotation;\n\n\t\t\t\t// Allow 3 pixels x2 padding either side for label readability\n\t\t\t\tvar tickWidth = me.getPixelForTick(1) - me.getPixelForTick(0) - 6;\n\n\t\t\t\t// Max label rotation can be set or default to 90 - also act as a loop counter\n\t\t\t\twhile (labelWidth > tickWidth && labelRotation < tickOpts.maxRotation) {\n\t\t\t\t\tvar angleRadians = helpers.toRadians(labelRotation);\n\t\t\t\t\tcosRotation = Math.cos(angleRadians);\n\t\t\t\t\tsinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\tif (sinRotation * originalLabelWidth > me.maxHeight) {\n\t\t\t\t\t\t// go back one step\n\t\t\t\t\t\tlabelRotation--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelRotation++;\n\t\t\t\t\tlabelWidth = cosRotation * originalLabelWidth;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.labelRotation = labelRotation;\n\t\t},\n\t\tafterCalculateTickRotation: function() {\n\t\t\thelpers.callback(this.options.afterCalculateTickRotation, [this]);\n\t\t},\n\n\t\t//\n\n\t\tbeforeFit: function() {\n\t\t\thelpers.callback(this.options.beforeFit, [this]);\n\t\t},\n\t\tfit: function() {\n\t\t\tvar me = this;\n\t\t\t// Reset\n\t\t\tvar minSize = me.minSize = {\n\t\t\t\twidth: 0,\n\t\t\t\theight: 0\n\t\t\t};\n\n\t\t\tvar labels = labelsFromTicks(me._ticks);\n\n\t\t\tvar opts = me.options;\n\t\t\tvar tickOpts = opts.ticks;\n\t\t\tvar scaleLabelOpts = opts.scaleLabel;\n\t\t\tvar gridLineOpts = opts.gridLines;\n\t\t\tvar display = opts.display;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar tickFont = parseFontOptions(tickOpts);\n\t\t\tvar tickMarkLength = opts.gridLines.tickMarkLength;\n\n\t\t\t// Width\n\t\t\tif (isHorizontal) {\n\t\t\t\t// subtract the margins to line up with the chartArea if we are a full width scale\n\t\t\t\tminSize.width = me.isFullWidth() ? me.maxWidth - me.margins.left - me.margins.right : me.maxWidth;\n\t\t\t} else {\n\t\t\t\tminSize.width = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t}\n\n\t\t\t// height\n\t\t\tif (isHorizontal) {\n\t\t\t\tminSize.height = display && gridLineOpts.drawTicks ? tickMarkLength : 0;\n\t\t\t} else {\n\t\t\t\tminSize.height = me.maxHeight; // fill all the height\n\t\t\t}\n\n\t\t\t// Are we showing a title for the scale?\n\t\t\tif (scaleLabelOpts.display && display) {\n\t\t\t\tvar scaleLabelLineHeight = parseLineHeight(scaleLabelOpts);\n\t\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabelOpts.padding);\n\t\t\t\tvar deltaHeight = scaleLabelLineHeight + scaleLabelPadding.height;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tminSize.height += deltaHeight;\n\t\t\t\t} else {\n\t\t\t\t\tminSize.width += deltaHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Don't bother fitting the ticks if we are not showing them\n\t\t\tif (tickOpts.display && display) {\n\t\t\t\tvar largestTextWidth = helpers.longestText(me.ctx, tickFont.font, labels, me.longestTextCache);\n\t\t\t\tvar tallestLabelHeightInLines = helpers.numberOfLabelLines(labels);\n\t\t\t\tvar lineSpace = tickFont.size * 0.5;\n\t\t\t\tvar tickPadding = me.options.ticks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\t// A horizontal axis is more constrained by the height.\n\t\t\t\t\tme.longestLabelWidth = largestTextWidth;\n\n\t\t\t\t\tvar angleRadians = helpers.toRadians(me.labelRotation);\n\t\t\t\t\tvar cosRotation = Math.cos(angleRadians);\n\t\t\t\t\tvar sinRotation = Math.sin(angleRadians);\n\n\t\t\t\t\t// TODO - improve this calculation\n\t\t\t\t\tvar labelHeight = (sinRotation * largestTextWidth)\n\t\t\t\t\t\t+ (tickFont.size * tallestLabelHeightInLines)\n\t\t\t\t\t\t+ (lineSpace * (tallestLabelHeightInLines - 1))\n\t\t\t\t\t\t+ lineSpace; // padding\n\n\t\t\t\t\tminSize.height = Math.min(me.maxHeight, minSize.height + labelHeight + tickPadding);\n\n\t\t\t\t\tme.ctx.font = tickFont.font;\n\t\t\t\t\tvar firstLabelWidth = computeTextSize(me.ctx, labels[0], tickFont.font);\n\t\t\t\t\tvar lastLabelWidth = computeTextSize(me.ctx, labels[labels.length - 1], tickFont.font);\n\n\t\t\t\t\t// Ensure that our ticks are always inside the canvas. When rotated, ticks are right aligned\n\t\t\t\t\t// which means that the right padding is dominated by the font height\n\t\t\t\t\tif (me.labelRotation !== 0) {\n\t\t\t\t\t\tme.paddingLeft = opts.position === 'bottom' ? (cosRotation * firstLabelWidth) + 3 : (cosRotation * lineSpace) + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = opts.position === 'bottom' ? (cosRotation * lineSpace) + 3 : (cosRotation * lastLabelWidth) + 3;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tme.paddingLeft = firstLabelWidth / 2 + 3; // add 3 px to move away from canvas edges\n\t\t\t\t\t\tme.paddingRight = lastLabelWidth / 2 + 3;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// A vertical axis is more constrained by the width. Labels are the\n\t\t\t\t\t// dominant factor here, so get that length first and account for padding\n\t\t\t\t\tif (tickOpts.mirror) {\n\t\t\t\t\t\tlargestTextWidth = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// use lineSpace for consistency with horizontal axis\n\t\t\t\t\t\t// tickPadding is not implemented for horizontal\n\t\t\t\t\t\tlargestTextWidth += tickPadding + lineSpace;\n\t\t\t\t\t}\n\n\t\t\t\t\tminSize.width = Math.min(me.maxWidth, minSize.width + largestTextWidth);\n\n\t\t\t\t\tme.paddingTop = tickFont.size / 2;\n\t\t\t\t\tme.paddingBottom = tickFont.size / 2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tme.handleMargins();\n\n\t\t\tme.width = minSize.width;\n\t\t\tme.height = minSize.height;\n\t\t},\n\n\t\t/**\n\t\t * Handle margins and padding interactions\n\t\t * @private\n\t\t */\n\t\thandleMargins: function() {\n\t\t\tvar me = this;\n\t\t\tif (me.margins) {\n\t\t\t\tme.paddingLeft = Math.max(me.paddingLeft - me.margins.left, 0);\n\t\t\t\tme.paddingTop = Math.max(me.paddingTop - me.margins.top, 0);\n\t\t\t\tme.paddingRight = Math.max(me.paddingRight - me.margins.right, 0);\n\t\t\t\tme.paddingBottom = Math.max(me.paddingBottom - me.margins.bottom, 0);\n\t\t\t}\n\t\t},\n\n\t\tafterFit: function() {\n\t\t\thelpers.callback(this.options.afterFit, [this]);\n\t\t},\n\n\t\t// Shared Methods\n\t\tisHorizontal: function() {\n\t\t\treturn this.options.position === 'top' || this.options.position === 'bottom';\n\t\t},\n\t\tisFullWidth: function() {\n\t\t\treturn (this.options.fullWidth);\n\t\t},\n\n\t\t// Get the correct value. NaN bad inputs, If the value type is object get the x or y based on whether we are horizontal or not\n\t\tgetRightValue: function(rawValue) {\n\t\t\t// Null and undefined values first\n\t\t\tif (helpers.isNullOrUndef(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// isNaN(object) returns true, so make sure NaN is checking for a number; Discard Infinite values\n\t\t\tif (typeof rawValue === 'number' && !isFinite(rawValue)) {\n\t\t\t\treturn NaN;\n\t\t\t}\n\t\t\t// If it is in fact an object, dive in one more level\n\t\t\tif (rawValue) {\n\t\t\t\tif (this.isHorizontal()) {\n\t\t\t\t\tif (rawValue.x !== undefined) {\n\t\t\t\t\t\treturn this.getRightValue(rawValue.x);\n\t\t\t\t\t}\n\t\t\t\t} else if (rawValue.y !== undefined) {\n\t\t\t\t\treturn this.getRightValue(rawValue.y);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Value is good, return it\n\t\t\treturn rawValue;\n\t\t},\n\n\t\t/**\n\t\t * Used to get the value to display in the tooltip for the data at the given index\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetLabelForIndex: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the given data point. Value can either be an index or a numerical value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param value\n\t\t * @param index\n\t\t * @param datasetIndex\n\t\t */\n\t\tgetPixelForValue: helpers.noop,\n\n\t\t/**\n\t\t * Used to get the data value from a given pixel. This is the inverse of getPixelForValue\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t * @param pixel\n\t\t */\n\t\tgetValueForPixel: helpers.noop,\n\n\t\t/**\n\t\t * Returns the location of the tick at the given index\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForTick: function(index) {\n\t\t\tvar me = this;\n\t\t\tvar offset = me.options.offset;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar tickWidth = innerWidth / Math.max((me._ticks.length - (offset ? 0 : 1)), 1);\n\t\t\t\tvar pixel = (tickWidth * index) + me.paddingLeft;\n\n\t\t\t\tif (offset) {\n\t\t\t\t\tpixel += tickWidth / 2;\n\t\t\t\t}\n\n\t\t\t\tvar finalVal = me.left + Math.round(pixel);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\tvar innerHeight = me.height - (me.paddingTop + me.paddingBottom);\n\t\t\treturn me.top + (index * (innerHeight / (me._ticks.length - 1)));\n\t\t},\n\n\t\t/**\n\t\t * Utility for getting the pixel location of a percentage of scale\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetPixelForDecimal: function(decimal) {\n\t\t\tvar me = this;\n\t\t\tif (me.isHorizontal()) {\n\t\t\t\tvar innerWidth = me.width - (me.paddingLeft + me.paddingRight);\n\t\t\t\tvar valueOffset = (innerWidth * decimal) + me.paddingLeft;\n\n\t\t\t\tvar finalVal = me.left + Math.round(valueOffset);\n\t\t\t\tfinalVal += me.isFullWidth() ? me.margins.left : 0;\n\t\t\t\treturn finalVal;\n\t\t\t}\n\t\t\treturn me.top + (decimal * me.height);\n\t\t},\n\n\t\t/**\n\t\t * Returns the pixel for the minimum chart value\n\t\t * The coordinate (0, 0) is at the upper-left corner of the canvas\n\t\t */\n\t\tgetBasePixel: function() {\n\t\t\treturn this.getPixelForValue(this.getBaseValue());\n\t\t},\n\n\t\tgetBaseValue: function() {\n\t\t\tvar me = this;\n\t\t\tvar min = me.min;\n\t\t\tvar max = me.max;\n\n\t\t\treturn me.beginAtZero ? 0 :\n\t\t\t\tmin < 0 && max < 0 ? max :\n\t\t\t\tmin > 0 && max > 0 ? min :\n\t\t\t\t0;\n\t\t},\n\n\t\t/**\n\t\t * Returns a subset of ticks to be plotted to avoid overlapping labels.\n\t\t * @private\n\t\t */\n\t\t_autoSkip: function(ticks) {\n\t\t\tvar skipRatio;\n\t\t\tvar me = this;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\t\t\tvar optionTicks = me.options.ticks.minor;\n\t\t\tvar tickCount = ticks.length;\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\t\t\tvar cosRotation = Math.cos(labelRotationRadians);\n\t\t\tvar longestRotatedLabel = me.longestLabelWidth * cosRotation;\n\t\t\tvar result = [];\n\t\t\tvar i, tick, shouldSkip;\n\n\t\t\t// figure out the maximum number of gridlines to show\n\t\t\tvar maxTicks;\n\t\t\tif (optionTicks.maxTicksLimit) {\n\t\t\t\tmaxTicks = optionTicks.maxTicksLimit;\n\t\t\t}\n\n\t\t\tif (isHorizontal) {\n\t\t\t\tskipRatio = false;\n\n\t\t\t\tif ((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount > (me.width - (me.paddingLeft + me.paddingRight))) {\n\t\t\t\t\tskipRatio = 1 + Math.floor(((longestRotatedLabel + optionTicks.autoSkipPadding) * tickCount) / (me.width - (me.paddingLeft + me.paddingRight)));\n\t\t\t\t}\n\n\t\t\t\t// if they defined a max number of optionTicks,\n\t\t\t\t// increase skipRatio until that number is met\n\t\t\t\tif (maxTicks && tickCount > maxTicks) {\n\t\t\t\t\tskipRatio = Math.max(skipRatio, Math.floor(tickCount / maxTicks));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (i = 0; i < tickCount; i++) {\n\t\t\t\ttick = ticks[i];\n\n\t\t\t\t// Since we always show the last tick,we need may need to hide the last shown one before\n\t\t\t\tshouldSkip = (skipRatio > 1 && i % skipRatio > 0) || (i % skipRatio === 0 && i + skipRatio >= tickCount);\n\t\t\t\tif (shouldSkip && i !== tickCount - 1) {\n\t\t\t\t\t// leave tick in place but make sure it's not displayed (#4635)\n\t\t\t\t\tdelete tick.label;\n\t\t\t\t}\n\t\t\t\tresult.push(tick);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\t// Actually draw the scale on the canvas\n\t\t// @param {rectangle} chartArea : the area of the chart to draw full grid lines on\n\t\tdraw: function(chartArea) {\n\t\t\tvar me = this;\n\t\t\tvar options = me.options;\n\t\t\tif (!options.display) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar context = me.ctx;\n\t\t\tvar globalDefaults = defaults.global;\n\t\t\tvar optionTicks = options.ticks.minor;\n\t\t\tvar optionMajorTicks = options.ticks.major || optionTicks;\n\t\t\tvar gridLines = options.gridLines;\n\t\t\tvar scaleLabel = options.scaleLabel;\n\n\t\t\tvar isRotated = me.labelRotation !== 0;\n\t\t\tvar isHorizontal = me.isHorizontal();\n\n\t\t\tvar ticks = optionTicks.autoSkip ? me._autoSkip(me.getTicks()) : me.getTicks();\n\t\t\tvar tickFontColor = helpers.valueOrDefault(optionTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar tickFont = parseFontOptions(optionTicks);\n\t\t\tvar majorTickFontColor = helpers.valueOrDefault(optionMajorTicks.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar majorTickFont = parseFontOptions(optionMajorTicks);\n\n\t\t\tvar tl = gridLines.drawTicks ? gridLines.tickMarkLength : 0;\n\n\t\t\tvar scaleLabelFontColor = helpers.valueOrDefault(scaleLabel.fontColor, globalDefaults.defaultFontColor);\n\t\t\tvar scaleLabelFont = parseFontOptions(scaleLabel);\n\t\t\tvar scaleLabelPadding = helpers.options.toPadding(scaleLabel.padding);\n\t\t\tvar labelRotationRadians = helpers.toRadians(me.labelRotation);\n\n\t\t\tvar itemsToDraw = [];\n\n\t\t\tvar axisWidth = me.options.gridLines.lineWidth;\n\t\t\tvar xTickStart = options.position === 'right' ? me.right : me.right - axisWidth - tl;\n\t\t\tvar xTickEnd = options.position === 'right' ? me.right + tl : me.right;\n\t\t\tvar yTickStart = options.position === 'bottom' ? me.top + axisWidth : me.bottom - tl - axisWidth;\n\t\t\tvar yTickEnd = options.position === 'bottom' ? me.top + axisWidth + tl : me.bottom + axisWidth;\n\n\t\t\thelpers.each(ticks, function(tick, index) {\n\t\t\t\t// autoskipper skipped this tick (#4635)\n\t\t\t\tif (helpers.isNullOrUndef(tick.label)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar label = tick.label;\n\t\t\t\tvar lineWidth, lineColor, borderDash, borderDashOffset;\n\t\t\t\tif (index === me.zeroLineIndex && options.offset === gridLines.offsetGridLines) {\n\t\t\t\t\t// Draw the first index specially\n\t\t\t\t\tlineWidth = gridLines.zeroLineWidth;\n\t\t\t\t\tlineColor = gridLines.zeroLineColor;\n\t\t\t\t\tborderDash = gridLines.zeroLineBorderDash;\n\t\t\t\t\tborderDashOffset = gridLines.zeroLineBorderDashOffset;\n\t\t\t\t} else {\n\t\t\t\t\tlineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, index);\n\t\t\t\t\tlineColor = helpers.valueAtIndexOrDefault(gridLines.color, index);\n\t\t\t\t\tborderDash = helpers.valueOrDefault(gridLines.borderDash, globalDefaults.borderDash);\n\t\t\t\t\tborderDashOffset = helpers.valueOrDefault(gridLines.borderDashOffset, globalDefaults.borderDashOffset);\n\t\t\t\t}\n\n\t\t\t\t// Common properties\n\t\t\t\tvar tx1, ty1, tx2, ty2, x1, y1, x2, y2, labelX, labelY;\n\t\t\t\tvar textAlign = 'middle';\n\t\t\t\tvar textBaseline = 'middle';\n\t\t\t\tvar tickPadding = optionTicks.padding;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tvar labelYOffset = tl + tickPadding;\n\n\t\t\t\t\tif (options.position === 'bottom') {\n\t\t\t\t\t\t// bottom\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'top' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'right';\n\t\t\t\t\t\tlabelY = me.top + labelYOffset;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// top\n\t\t\t\t\t\ttextBaseline = !isRotated ? 'bottom' : 'middle';\n\t\t\t\t\t\ttextAlign = !isRotated ? 'center' : 'left';\n\t\t\t\t\t\tlabelY = me.bottom - labelYOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar xLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (xLineValue < me.left) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\txLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelX = me.getPixelForTick(index) + optionTicks.labelOffset; // x values for optionTicks (need to consider offsetLabel option)\n\n\t\t\t\t\ttx1 = tx2 = x1 = x2 = xLineValue;\n\t\t\t\t\tty1 = yTickStart;\n\t\t\t\t\tty2 = yTickEnd;\n\t\t\t\t\ty1 = chartArea.top;\n\t\t\t\t\ty2 = chartArea.bottom + axisWidth;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tvar labelXOffset;\n\n\t\t\t\t\tif (optionTicks.mirror) {\n\t\t\t\t\t\ttextAlign = isLeft ? 'left' : 'right';\n\t\t\t\t\t\tlabelXOffset = tickPadding;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttextAlign = isLeft ? 'right' : 'left';\n\t\t\t\t\t\tlabelXOffset = tl + tickPadding;\n\t\t\t\t\t}\n\n\t\t\t\t\tlabelX = isLeft ? me.right - labelXOffset : me.left + labelXOffset;\n\n\t\t\t\t\tvar yLineValue = getLineValue(me, index, gridLines.offsetGridLines && ticks.length > 1);\n\t\t\t\t\tif (yLineValue < me.top) {\n\t\t\t\t\t\tlineColor = 'rgba(0,0,0,0)';\n\t\t\t\t\t}\n\t\t\t\t\tyLineValue += helpers.aliasPixel(lineWidth);\n\n\t\t\t\t\tlabelY = me.getPixelForTick(index) + optionTicks.labelOffset;\n\n\t\t\t\t\ttx1 = xTickStart;\n\t\t\t\t\ttx2 = xTickEnd;\n\t\t\t\t\tx1 = chartArea.left;\n\t\t\t\t\tx2 = chartArea.right + axisWidth;\n\t\t\t\t\tty1 = ty2 = y1 = y2 = yLineValue;\n\t\t\t\t}\n\n\t\t\t\titemsToDraw.push({\n\t\t\t\t\ttx1: tx1,\n\t\t\t\t\tty1: ty1,\n\t\t\t\t\ttx2: tx2,\n\t\t\t\t\tty2: ty2,\n\t\t\t\t\tx1: x1,\n\t\t\t\t\ty1: y1,\n\t\t\t\t\tx2: x2,\n\t\t\t\t\ty2: y2,\n\t\t\t\t\tlabelX: labelX,\n\t\t\t\t\tlabelY: labelY,\n\t\t\t\t\tglWidth: lineWidth,\n\t\t\t\t\tglColor: lineColor,\n\t\t\t\t\tglBorderDash: borderDash,\n\t\t\t\t\tglBorderDashOffset: borderDashOffset,\n\t\t\t\t\trotation: -1 * labelRotationRadians,\n\t\t\t\t\tlabel: label,\n\t\t\t\t\tmajor: tick.major,\n\t\t\t\t\ttextBaseline: textBaseline,\n\t\t\t\t\ttextAlign: textAlign\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// Draw all of the tick labels, tick marks, and grid lines at the correct places\n\t\t\thelpers.each(itemsToDraw, function(itemToDraw) {\n\t\t\t\tif (gridLines.display) {\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.lineWidth = itemToDraw.glWidth;\n\t\t\t\t\tcontext.strokeStyle = itemToDraw.glColor;\n\t\t\t\t\tif (context.setLineDash) {\n\t\t\t\t\t\tcontext.setLineDash(itemToDraw.glBorderDash);\n\t\t\t\t\t\tcontext.lineDashOffset = itemToDraw.glBorderDashOffset;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.beginPath();\n\n\t\t\t\t\tif (gridLines.drawTicks) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.tx1, itemToDraw.ty1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.tx2, itemToDraw.ty2);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (gridLines.drawOnChartArea) {\n\t\t\t\t\t\tcontext.moveTo(itemToDraw.x1, itemToDraw.y1);\n\t\t\t\t\t\tcontext.lineTo(itemToDraw.x2, itemToDraw.y2);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontext.stroke();\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\n\t\t\t\tif (optionTicks.display) {\n\t\t\t\t\t// Make sure we draw text in the correct color and font\n\t\t\t\t\tcontext.save();\n\t\t\t\t\tcontext.translate(itemToDraw.labelX, itemToDraw.labelY);\n\t\t\t\t\tcontext.rotate(itemToDraw.rotation);\n\t\t\t\t\tcontext.font = itemToDraw.major ? majorTickFont.font : tickFont.font;\n\t\t\t\t\tcontext.fillStyle = itemToDraw.major ? majorTickFontColor : tickFontColor;\n\t\t\t\t\tcontext.textBaseline = itemToDraw.textBaseline;\n\t\t\t\t\tcontext.textAlign = itemToDraw.textAlign;\n\n\t\t\t\t\tvar label = itemToDraw.label;\n\t\t\t\t\tif (helpers.isArray(label)) {\n\t\t\t\t\t\tvar lineCount = label.length;\n\t\t\t\t\t\tvar lineHeight = tickFont.size * 1.5;\n\t\t\t\t\t\tvar y = me.isHorizontal() ? 0 : -lineHeight * (lineCount - 1) / 2;\n\n\t\t\t\t\t\tfor (var i = 0; i < lineCount; ++i) {\n\t\t\t\t\t\t\t// We just make sure the multiline element is a string here..\n\t\t\t\t\t\t\tcontext.fillText('' + label[i], 0, y);\n\t\t\t\t\t\t\t// apply same lineSpacing as calculated @ L#320\n\t\t\t\t\t\t\ty += lineHeight;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.fillText(label, 0, 0);\n\t\t\t\t\t}\n\t\t\t\t\tcontext.restore();\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tif (scaleLabel.display) {\n\t\t\t\t// Draw the scale label\n\t\t\t\tvar scaleLabelX;\n\t\t\t\tvar scaleLabelY;\n\t\t\t\tvar rotation = 0;\n\t\t\t\tvar halfLineHeight = parseLineHeight(scaleLabel) / 2;\n\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\tscaleLabelX = me.left + ((me.right - me.left) / 2); // midpoint of the width\n\t\t\t\t\tscaleLabelY = options.position === 'bottom'\n\t\t\t\t\t\t? me.bottom - halfLineHeight - scaleLabelPadding.bottom\n\t\t\t\t\t\t: me.top + halfLineHeight + scaleLabelPadding.top;\n\t\t\t\t} else {\n\t\t\t\t\tvar isLeft = options.position === 'left';\n\t\t\t\t\tscaleLabelX = isLeft\n\t\t\t\t\t\t? me.left + halfLineHeight + scaleLabelPadding.top\n\t\t\t\t\t\t: me.right - halfLineHeight - scaleLabelPadding.top;\n\t\t\t\t\tscaleLabelY = me.top + ((me.bottom - me.top) / 2);\n\t\t\t\t\trotation = isLeft ? -0.5 * Math.PI : 0.5 * Math.PI;\n\t\t\t\t}\n\n\t\t\t\tcontext.save();\n\t\t\t\tcontext.translate(scaleLabelX, scaleLabelY);\n\t\t\t\tcontext.rotate(rotation);\n\t\t\t\tcontext.textAlign = 'center';\n\t\t\t\tcontext.textBaseline = 'middle';\n\t\t\t\tcontext.fillStyle = scaleLabelFontColor; // render in correct colour\n\t\t\t\tcontext.font = scaleLabelFont.font;\n\t\t\t\tcontext.fillText(scaleLabel.labelString, 0, 0);\n\t\t\t\tcontext.restore();\n\t\t\t}\n\n\t\t\tif (gridLines.drawBorder) {\n\t\t\t\t// Draw the line at the edge of the axis\n\t\t\t\tcontext.lineWidth = helpers.valueAtIndexOrDefault(gridLines.lineWidth, 0);\n\t\t\t\tcontext.strokeStyle = helpers.valueAtIndexOrDefault(gridLines.color, 0);\n\t\t\t\tvar x1 = me.left;\n\t\t\t\tvar x2 = me.right + axisWidth;\n\t\t\t\tvar y1 = me.top;\n\t\t\t\tvar y2 = me.bottom + axisWidth;\n\n\t\t\t\tvar aliasPixel = helpers.aliasPixel(context.lineWidth);\n\t\t\t\tif (isHorizontal) {\n\t\t\t\t\ty1 = y2 = options.position === 'top' ? me.bottom : me.top;\n\t\t\t\t\ty1 += aliasPixel;\n\t\t\t\t\ty2 += aliasPixel;\n\t\t\t\t} else {\n\t\t\t\t\tx1 = x2 = options.position === 'left' ? me.right : me.left;\n\t\t\t\t\tx1 += aliasPixel;\n\t\t\t\t\tx2 += aliasPixel;\n\t\t\t\t}\n\n\t\t\t\tcontext.beginPath();\n\t\t\t\tcontext.moveTo(x1, y1);\n\t\t\t\tcontext.lineTo(x2, y2);\n\t\t\t\tcontext.stroke();\n\t\t\t}\n\t\t}\n\t});\n};\n"]},"metadata":{},"sourceType":"script"}